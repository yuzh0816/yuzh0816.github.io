<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>yuzh的博客</title>
    <link>https://yuzh.tech/</link>
    
    <atom:link href="https://yuzh.tech/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Tue, 25 Mar 2025 04:29:39 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>字符串基础</title>
      <link>https://yuzh.tech/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E7%A1%80/</link>
      <guid>https://yuzh.tech/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E7%A1%80/</guid>
      <pubDate>Sat, 22 Mar 2025 15:10:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;字符串哈希&quot;&gt;&lt;a href=&quot;#字符串哈希&quot; class=&quot;headerlink&quot; title=&quot;字符串哈希&quot;&gt;&lt;/a&gt;字符串哈希&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>字符串哈希就是通过一种计算方法，将每个不同的字符串映射成不同的数值。</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><ol><li>把字符串映射成一个 p 进制数字。<br>对于一个长度为 n 的字符串 s，<br>这样定义 Hash 函数：<code>h(s) = ∑(i=1 to n) s[i] × p^(n-i) (mod M)</code><br>例如，字符串 abc，其哈希函数值为 <code>a*p^2 + b*p^1 + c</code><br>即 <code>97 × 131^2 + 98 × 131^1 + 99</code></li><li>如果两字符串不一样，Hash 函数值却一样，这样的现象称为<strong>哈希碰撞</strong>。</li><li>解决哈希碰撞的方法：<br>(1) p 通常取质数 131 或 13331<br>(2) M 通常取大整数 2^64，把哈希函数值 h 定义为 ULL，超过则自动溢出，等价于取模。</li></ol><p>求一个字符串的哈希值相当于求前缀和，求一个字符串的子串的哈希值相当于求区间和。</p><h1 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>当字符串 S 中选定一个位置 i 满足 S[i<del>n] + S[1</del>i-1] &#x3D; T，则 T 是 S 的循环同构串。</p><p>设 S &#x3D; “BCAD”，其循环同构串有“BCAD”、“CADB”、“ADBC”、“DBCA”， 当 i&#x3D;3 时，得到字典序最小的循环同构串是“ADBC”。</p><p><strong>最小表示法</strong>就是找出字符串 S 的循环同构串中字典序最小的那一个。</p><p>对于循环串（或环），通常的技巧就是复制一倍，<strong>破环成链</strong>，然后扫描。 用三个变量指针控制扫描，指针 i,j 控制匹配起始位置，指针 k 控制匹配长度。</p><h2 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h2><ol><li>把字符串复制一倍</li><li>初始化指针 i&#x3D;1，j&#x3D;2，匹配长度k&#x3D;0；</li><li>比较s[i+k]和s[j+k]是否相等，<br>(1)s[i+k]&#x3D;&#x3D;s[j+k]，则 k++;<br>(2)s[i+k]&gt;s[j+k]，则 i&#x3D;i+k+1；<br>(3)s[i+k]&lt;s[j+k]，则 j&#x3D;j+k+1；<br>若跳转后两个指针相同，则 j++，以<br>确保比较的两个字符串不同；</li><li>重复上述过程，直到比较结束；</li><li>答案为 min(i, j)。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 3000010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,a[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">2</span>,k=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        a[i+n]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n &amp;&amp; j&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==j)</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i+k]==a[j+k]) k++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i+k]&gt;a[j+k]) i+=k<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">else</span> j+=k<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&gt;a[j]) s=j;</span><br><span class="line">    <span class="keyword">else</span> s=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;n;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a[s+t]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p>给定一个模式串P和一个主串S，求模式串P在主串S中出现的位置。（字符串的下标均从1开始）</p><ol><li>取最长的相等前后缀，可以保证不漏解。</li><li>通过模式串前后缀的自我匹配的长度，计算 next 函数，给 j 指针打一张表，失配时就跳到 next[j] 的位置继续匹配。</li></ol><h2 id="next函数"><a href="#next函数" class="headerlink" title="next函数"></a>next函数</h2><p>next[i] 表示模式串 P[1..i] 中相等前后缀的最长长度</p><p>P             a a b a a b a a a a<br>ne[1]&#x3D;0  a<br>ne[2]&#x3D;1  a a<br>ne[3]&#x3D;0  a a b<br>ne[4]&#x3D;1  a a b a<br>ne[5]&#x3D;2  a a b a a<br>ne[6]&#x3D;3  a a b a a b<br>ne[7]&#x3D;4  a a b a a b a<br>ne[8]&#x3D;5  a a b a a b a a<br>ne[9]&#x3D;2  a a b a a b a a a<br>ne[10]&#x3D;2 a a b a a b a a a a</p><p>定义双指针：i 扫描模式串，j 扫描前缀。<br>初始化，ne[1]&#x3D;0, i&#x3D;2, j&#x3D;0。<br>每轮 for 循环，i 向右走一步。</p><ol><li>若 P[i]!&#x3D;P[j+1]，让 j 回跳到能匹配的位置，<br>如果找不到能匹配的位置，j 回跳到 0。</li><li>若 P[i]&#x3D;&#x3D;P[j+1]，让 j+1，指向匹配前缀的末尾。</li><li>next[i] 等于 j 的值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; p[i<span class="number">-1</span>]!=p[j]) j=nxt[j];</span><br><span class="line">    <span class="keyword">if</span>(p[i<span class="number">-1</span>]==p[j]) j++;</span><br><span class="line">    nxt[i]=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E7%A1%80/image-20250323152907285.png" alt="next函数过程"></p><h2 id="模式串与主串匹配"><a href="#模式串与主串匹配" class="headerlink" title="模式串与主串匹配"></a>模式串与主串匹配</h2><p>双指针：i 扫描主串，j 扫描模式串。<br>初始化，i&#x3D;1, j&#x3D;0。<br>每轮 for，i 向右走一步。</p><ol><li>若S[i]!&#x3D;P[j+1]，让 j 回跳到能匹配的位置，<br>如果找不到能匹配的位置，j 回跳到 0。</li><li>若S[i]&#x3D;&#x3D;P[j+1]，让 j 向右走一步。</li><li>若匹配成功，输出匹配位置。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; s[i<span class="number">-1</span>]!=p[j]) j=nxt[j];</span><br><span class="line">    <span class="keyword">if</span>(s[i<span class="number">-1</span>]==p[j]) j++;</span><br><span class="line">    <span class="keyword">if</span>(j==n) cout&lt;&lt;i-n<span class="number">+1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E7%A1%80/image-20250323153342268.png" alt="模式串匹配过程"></p>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://yuzh.tech/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9F%BA%E7%A1%80/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Tarjan三兄弟</title>
      <link>https://yuzh.tech/posts/tarjan/</link>
      <guid>https://yuzh.tech/posts/tarjan/</guid>
      <pubDate>Thu, 20 Mar 2025 15:00:52 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;Tarjan-缩点【校园网络】&quot;&gt;&lt;a href=&quot;#Tarjan-缩点【校园网络】&quot; class=&quot;headerlink&quot; title=&quot;Tarjan 缩点【校园网络】&quot;&gt;&lt;/a&gt;Tarjan 缩点【校园网络】&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/posts/t</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="Tarjan-缩点【校园网络】"><a href="#Tarjan-缩点【校园网络】" class="headerlink" title="Tarjan 缩点【校园网络】"></a>Tarjan 缩点【校园网络】</h2><p><img src="/posts/tarjan/image-20250323194135410.png" alt="image-20250323194135410"></p><h3 id="P2812-校园网络【-USACO-Network-of-Schools加强版】"><a href="#P2812-校园网络【-USACO-Network-of-Schools加强版】" class="headerlink" title="P2812 校园网络【[USACO]Network of Schools加强版】"></a>P2812 校园网络【[USACO]Network of Schools加强版】</h3><p>共有 <em>n</em> 所学校 (1≤<em>n</em>≤10000) 已知他们实现设计好的网络共 <em>m</em> 条线路，为了保证高速，网络是单向的。现在请你告诉他们至少选几所学校作为共享软件的母机，能使每所学校都可以用上。再告诉他们至少要添加几条线路能使任意一所学校作为母机都可以使别的学校使用上软件。</p><p>题目大意</p><ol><li><p>统计缩点后入度为0的点的个数。</p></li><li><p>答案是 max(din&#x3D;&#x3D;0, dout&#x3D;&#x3D;0)。 加边后构成一个环，即所有点的入度不为0且出度不为0。故缩点后分别统计入度为0 出度为0的点的个数，取 max 即可。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dfn[<span class="number">1000010</span>], low[<span class="number">1000010</span>], tot=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt;stk;</span><br><span class="line"><span class="type">bool</span> instk[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">int</span> scc[<span class="number">1000010</span>], siz[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from, to, next;</span><br><span class="line">&#125;edge[<span class="number">1000010</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">1000010</span>], cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].from=u;</span><br><span class="line">    edge[cnt].to=v;</span><br><span class="line">    edge[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++tot;</span><br><span class="line">    stk.<span class="built_in">push</span>(u);</span><br><span class="line">    instk[u]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) <span class="built_in">tarjan</span>(v), low[u]=<span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instk[v]) low[u]=<span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(low[u]==dfn[u])</span><br><span class="line">    &#123;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            instk[v]=<span class="literal">false</span>;</span><br><span class="line">            scc[v]=num;</span><br><span class="line">            siz[num]++;</span><br><span class="line">            <span class="keyword">if</span>(v==u) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> din[<span class="number">1000010</span>], dout[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">add</span>(i, a);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=head[i];j!=<span class="number">-1</span>;j=edge[j].next)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">int</span> v=edge[j].to;</span><br><span class="line">    <span class="keyword">if</span>(scc[i]!=scc[v])</span><br><span class="line">    &#123;</span><br><span class="line">    din[scc[v]]++;</span><br><span class="line">    dout[scc[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a=<span class="number">0</span>, b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!din[i]) a++;</span><br><span class="line"><span class="keyword">if</span>(!dout[i]) b++;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span>(num==<span class="number">1</span>) cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="built_in">max</span>(a,b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tarjan-割点"><a href="#Tarjan-割点" class="headerlink" title="Tarjan 割点"></a>Tarjan 割点</h2><p>割点：对于一个<strong>无向图</strong>，如果<strong>把一个点删除</strong>后，<strong>连通块的个数增加</strong>了，那么这个点就是<strong>割点</strong>（割顶）。</p><p>割点判定法则： 如果 x 不是根节点，当搜索树上存在 x 的一个子节点 y，满足 **low[y]≥dfn[x]**，那么 x 就是割点。 如果 x 是根节点，当搜索树上存在至少两个子节点 y1,y2，满足上述条件，那么 x 就是割点。</p><p>low[y]≥dfn[x]，说明从 y 出发，在不通过 x 点的前提下，不管走哪条边，都无法到达比 x 更早访问的节点。故删除 x 点后，以 y 为根的子树 subtree(y) 也就断开了。即环顶的点割得掉。 反之，若 low[y]&lt;dfn[x]，则说明 y 能绕行其他边到达比 x 更早访问的节点，x 就不是割点了。即环内的点割不掉。</p><p><img src="/posts/tarjan/image-20250323194412235.png" alt="样例数据"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000010</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,root; <span class="comment">// n个城市、m条道路</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dfn[MAXN], low[MAXN], tot=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> scc[MAXN], siz[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> cut[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from, to, next;</span><br><span class="line">&#125;edge[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[MAXN], cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].from=u;</span><br><span class="line">    edge[cnt].to=v;</span><br><span class="line">    edge[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> child=<span class="number">0</span>;</span><br><span class="line">    dfn[u]=low[u]=++tot;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v]&gt;=dfn[u])</span><br><span class="line">            &#123;</span><br><span class="line">                child++;</span><br><span class="line">                <span class="keyword">if</span>(u!=root || child&gt;<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    cut[u]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        <span class="built_in">add</span>(u,v), <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(root=<span class="number">1</span>;root&lt;=n;root++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[root]) <span class="built_in">tarjan</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cut[i]==<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(cut[i]) cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tarjan-割边"><a href="#Tarjan-割边" class="headerlink" title="Tarjan 割边"></a>Tarjan 割边</h2><p>割边：对于一个<strong>无向图</strong>，如果<strong>删掉一条边后</strong>图中的<strong>连通块个数增加</strong>了，则称这条边为<strong>桥</strong>或者<strong>割边</strong>。</p><p>割边判定法则： 当搜索树上存在 x 的一个子节点 y，满足 **low[y]&gt;dfn[x]**，则 (x,y) 这条边就是割边。</p><p>low[y]&gt;dfn[x]，说明从 y 出发，在不经过 (x,y) 这条边的前提下，不管走哪条边，都无法到达 x 或 更早访问的节点。故删除 (x,y) 这条边，以 y 为根的子树 subtree(y) 也就断开了。即环外的边割得断。 反之，若 low[y]&lt;&#x3D;dfn[x]，则说明 y 能<strong>绕行其他边到达 x 或更早访问的节点</strong>，(x,y) 就不是割边了。即<strong>环内的边割不断</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000010</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,root; <span class="comment">// n个城市、m条道路</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dfn[MAXN], low[MAXN], tot=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> scc[MAXN], siz[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> cut[MAXN*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from, to, next, cut=<span class="literal">false</span>;</span><br><span class="line">&#125;edge[MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[MAXN], cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].from=u;</span><br><span class="line">    edge[cnt].to=v;</span><br><span class="line">    edge[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++tot;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v, u);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v]&gt;dfn[u])</span><br><span class="line">            &#123;</span><br><span class="line">                edge[i].cut=<span class="literal">true</span>;</span><br><span class="line">                edge[i^<span class="number">1</span>].cut=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">OriE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">&#125;e[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(OriE a, OriE b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.from&lt;b.from) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.from==b.from) <span class="keyword">return</span> a.to&lt;b.to;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        <span class="keyword">if</span>(u&gt;v) <span class="built_in">swap</span>(u,v);</span><br><span class="line">        e[i].from=u, e[i].to=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(e<span class="number">+1</span>, e+m<span class="number">+1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(e[i].from, e[i].to);</span><br><span class="line">        <span class="built_in">add</span>(e[i].to, e[i].from);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(root=<span class="number">1</span>;root&lt;=n;root++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[root]) <span class="built_in">tarjan</span>(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i+=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span>(edge[i].cut==<span class="literal">true</span>) cout&lt;&lt;edge[i].from&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;edge[i].to&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://yuzh.tech/posts/tarjan/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>倍增</title>
      <link>https://yuzh.tech/posts/binary-lifting/</link>
      <guid>https://yuzh.tech/posts/binary-lifting/</guid>
      <pubDate>Sat, 01 Feb 2025 14:14:07 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;倍增&quot;&gt;&lt;a href=&quot;#倍增&quot; class=&quot;headerlink&quot; title=&quot;倍增&quot;&gt;&lt;/a&gt;倍增&lt;/h1&gt;&lt;h2 id=&quot;ST表&quot;&gt;&lt;a href=&quot;#ST表&quot; class=&quot;headerlink&quot; title=&quot;ST表&quot;&gt;&lt;/a&gt;ST表&lt;/h2&gt;&lt;p</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h1><h2 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h2><p>主要用来解决<strong>RMQ</strong>(区间最大&#x2F;最小值查询)问题。应用倍增思想,可以实现O(nlogn)预处理、O(1)查询。</p><ol><li><p>预处理ST表<br><code>f[i][j]</code>表示以第i个数为起点,长度为2^j的区间中的最大值，即<code>f[i][j] = max(f[i][j -1], f[i+2^(j-1)][j-1])</code></p></li><li><p>处理询问</p><p>对查询区间[l,r]做分割、拼凑。区间长度的指数k&#x3D;log2(r-l+1)，并且区间[l,r]必可以由两个长度为2^k的区间重叠取最值，即<code>max(f[l][k],f[r-2^k+1][k])</code></p></li></ol><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="comment">// f[i][j]表示以第i个数为起点,长度为2^j的区间中的最大值</span></span><br><span class="line"><span class="type">int</span> f[<span class="number">100010</span>][<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;f[i][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 预处理ST表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">30</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">f[i][j]=<span class="built_in">max</span>(f[i][j<span class="number">-1</span>], f[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 处理询问</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,l,r;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="type">int</span> k=<span class="built_in">log2</span>(r-l<span class="number">+1</span>);</span><br><span class="line">cout&lt;&lt;<span class="built_in">max</span>(f[l][k], f[r-(<span class="number">1</span>&lt;&lt;k)<span class="number">+1</span>][k])&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>题干见<a href="https://www.luogu.com.cn/problem/P3379">P3379 【模板】最近公共祖先（LCA）</a>。</p><p>给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。</p><p>实现分为两个阶段。第一个阶段将两个节点跳到同一高度，第二阶段将两个节点一同向上移动，直至找到最近公共祖先。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> from, to, next;</span><br><span class="line">&#125;edge[<span class="number">1000010</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">1000010</span>], cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[cnt].from=x;</span><br><span class="line">edge[cnt].to=y;</span><br><span class="line">edge[cnt].next=head[x];</span><br><span class="line">head[x]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,s,a,b;</span><br><span class="line"><span class="comment">// dep存节点深度，fa[u][i]存从u点向上跳2^i次的节点(i从0开始计算)</span></span><br><span class="line"><span class="type">int</span> dep[<span class="number">500010</span>], fa[<span class="number">500010</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dep[u]=dep[father]<span class="number">+1</span>;</span><br><span class="line">fa[u][<span class="number">0</span>]=father;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">19</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to!=father) <span class="built_in">dfs</span>(edge[i].to, u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 第一阶段 将u、v跳到同一层</span></span><br><span class="line"><span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[fa[u][i]]&gt;=dep[v]) u=fa[u][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u==v) <span class="keyword">return</span> u;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二阶段 将u、v跳到lca的下一层</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[u][i]!=fa[v][i])</span><br><span class="line">&#123;</span><br><span class="line">u=fa[u][i];</span><br><span class="line">v=fa[v][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) head[i]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="built_in">add</span>(a,b), <span class="built_in">add</span>(b,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">cout&lt;&lt;<span class="built_in">lca</span>(a,b)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询树上两点间路径上边权的最小值"><a href="#查询树上两点间路径上边权的最小值" class="headerlink" title="查询树上两点间路径上边权的最小值"></a>查询树上两点间路径上边权的最小值</h3><p>在原本最近公共祖先的基础上加以minn数组存储最小值即可，完整代码见下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,s,a,b,w;</span><br><span class="line"><span class="comment">// dep存节点深度，fa[u][i]存从u点向上跳2^i次的节点(i从0开始计算)</span></span><br><span class="line"><span class="type">int</span> dep[<span class="number">500010</span>], fa[<span class="number">500010</span>][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> minn[<span class="number">500010</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dep[u]=dep[father]<span class="number">+1</span>;</span><br><span class="line">fa[u][<span class="number">0</span>]=father;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">19</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">minn[u][i]=<span class="built_in">min</span>(minn[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>], minn[u][i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to!=father)</span><br><span class="line">&#123;</span><br><span class="line">minn[edge[i].to][<span class="number">0</span>]=edge[i].weight;</span><br><span class="line"><span class="built_in">dfs</span>(edge[i].to, u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0x7f7f7f7f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一阶段 将u、v跳到同一层</span></span><br><span class="line"><span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[fa[u][i]]&gt;=dep[v]) ans=<span class="built_in">min</span>(ans, minn[u][i]) ,u=fa[u][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u==v) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二阶段 将u、v跳到lca的下一层</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[u][i]!=fa[v][i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 先赋完值再往上跳</span></span><br><span class="line">ans=<span class="built_in">min</span>(ans, <span class="built_in">min</span>(minn[u][i], minn[v][i]));</span><br><span class="line">u=fa[u][i];</span><br><span class="line">v=fa[v][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans=<span class="built_in">min</span>(ans, <span class="built_in">min</span>(minn[u][<span class="number">0</span>], minn[v][<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line"><span class="built_in">add</span>(a,b,w), <span class="built_in">add</span>(b,a,w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可用此数据测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">5 5 4</span><br><span class="line">3 1 1</span><br><span class="line">2 4 6</span><br><span class="line">5 1 3</span><br><span class="line">1 4 5</span><br><span class="line">2 4</span><br><span class="line">3 2</span><br><span class="line">3 5</span><br><span class="line">1 2</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h3 id="NOIP-2013-T3-货车运输"><a href="#NOIP-2013-T3-货车运输" class="headerlink" title="NOIP 2013 T3 货车运输"></a>NOIP 2013 T3 货车运输</h3><p>本题先使用Kruskal算法建立最大生成树，随后使用上方的方法查询两点路径最小值即可得到答案。</p><p>注意，本题需要对所有没经过的点跑一遍dfs，保证所有点都被完整遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// union-find</span></span><br><span class="line"><span class="type">int</span> ufa[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ufa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> ufa[x]=<span class="built_in">find</span>(ufa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ufa[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> from, to, weight;</span><br><span class="line">&#125;node[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.weight&gt;b.weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">1000010</span>];</span><br><span class="line"><span class="type">bool</span> dfs_vis[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>  to, next, weight;</span><br><span class="line">&#125;edge[<span class="number">1000010</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">1000010</span>], cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[cnt].to=y;</span><br><span class="line">edge[cnt].weight=z;</span><br><span class="line">edge[cnt].next=head[x];</span><br><span class="line">head[x]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dep存节点深度，fa[u][i]存从u点向上跳2^i次的节点(i从0开始计算)</span></span><br><span class="line"><span class="type">int</span> dep[<span class="number">500010</span>], fa[<span class="number">500010</span>][<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> minn[<span class="number">500010</span>][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfs_vis[u]=<span class="literal">true</span>;</span><br><span class="line">dep[u]=dep[father]<span class="number">+1</span>;</span><br><span class="line">fa[u][<span class="number">0</span>]=father;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">29</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">minn[u][i]=<span class="built_in">min</span>(minn[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>], minn[u][i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to!=father)</span><br><span class="line">&#123;</span><br><span class="line">minn[edge[i].to][<span class="number">0</span>]=edge[i].weight;</span><br><span class="line"><span class="built_in">dfs</span>(edge[i].to, u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0x7f7f7f7f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一阶段 将u、v跳到同一层</span></span><br><span class="line"><span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">29</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[fa[u][i]]&gt;=dep[v]) ans=<span class="built_in">min</span>(ans, minn[u][i]) ,u=fa[u][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u==v) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二阶段 将u、v跳到lca的下一层</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">29</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[u][i]!=fa[v][i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 先赋完值再往上跳</span></span><br><span class="line">ans=<span class="built_in">min</span>(ans, <span class="built_in">min</span>(minn[u][i], minn[v][i]));</span><br><span class="line">u=fa[u][i];</span><br><span class="line">v=fa[v][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans=<span class="built_in">min</span>(ans, <span class="built_in">min</span>(minn[u][<span class="number">0</span>], minn[v][<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) head[i]=<span class="number">-1</span>, ufa[i]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;node[i].from&gt;&gt;node[i].to&gt;&gt;node[i].weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(node<span class="number">+1</span>, node<span class="number">+1</span>+m, cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(node[i].from)!=<span class="built_in">find</span>(node[i].to))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">add</span>(node[i].from, node[i].to, node[i].weight);</span><br><span class="line"><span class="built_in">add</span>(node[i].to, node[i].from, node[i].weight);</span><br><span class="line"><span class="built_in">merge</span>(node[i].from, node[i].to);</span><br><span class="line">vis[node[i].from]=<span class="literal">true</span>;</span><br><span class="line">vis[node[i].to]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dfs_vis[i]==<span class="literal">false</span>)&#123;</span><br><span class="line"><span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> q;</span><br><span class="line">cin&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b;i&lt;=q;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(a)!=<span class="built_in">find</span>(b)) cout&lt;&lt;<span class="string">&quot;-1&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="built_in">lca</span>(a,b)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://yuzh.tech/posts/binary-lifting/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>线段树</title>
      <link>https://yuzh.tech/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91/</link>
      <guid>https://yuzh.tech/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91/</guid>
      <pubDate>Mon, 21 Oct 2024 10:40:10 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;线段树&quot;&gt;&lt;a href=&quot;#线段树&quot; class=&quot;headerlink&quot; title=&quot;线段树&quot;&gt;&lt;/a&gt;线段树&lt;/h1&gt;&lt;h2 id=&quot;建树与维护&quot;&gt;&lt;a href=&quot;#建树与维护&quot; class=&quot;headerlink&quot; title=&quot;建树与维护&quot;&gt;&lt;/a&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h2 id="建树与维护"><a href="#建树与维护" class="headerlink" title="建树与维护"></a>建树与维护</h2><p>对于每个父亲节点<code>i</code>，它的两个儿子节点为<code>2i</code>，<code>2i+1</code>，故写函数<code>ls</code>，<code>rs</code>来获取当前节点的儿子节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ls</span><span class="params">(<span class="type">int</span> p)</span></span>&#123; <span class="keyword">return</span> p*<span class="number">2</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> p)</span></span>&#123; <span class="keyword">return</span> p*<span class="number">2</span><span class="number">+1</span>; &#125;</span><br></pre></td></tr></table></figure><p> <code>inline</code> 可以有效防止无需入栈的信息入栈，节省时间和空间。</p><p>维护线段树采用<code>push_up</code>函数，功能是<strong>维护父子节点之间的逻辑关系</strong>，实际上是在合并两个子节点的信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向上维护区间操作</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ans[p]=ans[<span class="built_in">ls</span>(p)]+ans[<span class="built_in">rs</span>(p)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再建树的递归中，需要<strong>先去整合子节点的信息</strong>，再向它们的祖先回溯整合之后的信息。建树的<code>build</code>函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tag[p]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123; <span class="comment">// 如果区间的左右相同，则必为叶子节点，</span></span><br><span class="line">ans[p]=a[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(<span class="built_in">ls</span>(p), l, mid);</span><br><span class="line"><span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid<span class="number">+1</span>, r);</span><br><span class="line"><span class="built_in">push_up</span>(p); <span class="comment">// 由于是通过子节点维护父节点，push_up需要再最后进行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h2><p>在区间修改中，引入<strong>懒标记</strong>，在下方代码在中记为<code>tag</code>，作用是记录每次、每个节点要更新的值，从而降低区间更新的时间复杂度。</p><p>下方的f函数用于对线段树的某个节点所代表的区间进行更新操作，<code>p</code>为节点编号，<code>tag[p]</code>为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tag[p]=tag[p]+k;</span><br><span class="line">ans[p]=ans[p]+k*(r-l<span class="number">+1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向下传递信息时使用<code>push_down</code>来维护线段树：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 每次push_down都需要更新两个子节点的数值</span></span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">ls</span>(p), l, mid, tag[p]);</span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">rs</span>(p), mid<span class="number">+1</span>, r, tag[p]);</span><br><span class="line">tag[p]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下方是<code>update</code>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nl、nr为需要修改的区间；l，r，p为当前节点所存储的区间以及节点的编号</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> nl, <span class="type">int</span> nr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(nl&lt;=l&amp;&amp;r&lt;=nr)</span><br><span class="line">&#123;</span><br><span class="line">ans[p]+=k*(r-l<span class="number">+1</span>);</span><br><span class="line">tag[p]+=k;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">push_down</span>(p, l, r);</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nl&lt;=mid) <span class="built_in">update</span>(nl, nr, l, mid, <span class="built_in">ls</span>(p), k);</span><br><span class="line"><span class="keyword">if</span>(nr&gt;mid) <span class="built_in">update</span>(nl, nr, mid<span class="number">+1</span>, r,<span class="built_in">rs</span>(p), k);</span><br><span class="line"><span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><p>结构与区间更新类似，利用到了分块的思想</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> q_x, <span class="type">int</span> q_y, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(q_x&lt;=l &amp;&amp; r&lt;=q_y) <span class="keyword">return</span> ans[p];</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">push_down</span>(p,l,r);</span><br><span class="line"><span class="keyword">if</span>(q_x&lt;=mid) res+=<span class="built_in">query</span>(q_x, q_y, l, mid, <span class="built_in">ls</span>(p));</span><br><span class="line"><span class="keyword">if</span>(q_y&gt;mid) res+=<span class="built_in">query</span>(q_x, q_y, mid<span class="number">+1</span>, r, <span class="built_in">rs</span>(p));</span><br><span class="line"><span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码示例"><a href="#完整代码示例" class="headerlink" title="完整代码示例"></a>完整代码示例</h2><p>模板：<a href="https://www.luogu.com.cn/problem/P3372">洛谷 P3372【模板】线段树</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> ans[MAXN*<span class="number">4</span>], a[MAXN], tag[MAXN*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ls</span><span class="params">(<span class="type">int</span> p)</span></span>&#123; <span class="keyword">return</span> p*<span class="number">2</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> p)</span></span>&#123; <span class="keyword">return</span> p*<span class="number">2</span><span class="number">+1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ans[p]=ans[<span class="built_in">ls</span>(p)]+ans[<span class="built_in">rs</span>(p)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tag[p]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">ans[p]=a[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(<span class="built_in">ls</span>(p), l, mid);</span><br><span class="line"><span class="built_in">build</span>(<span class="built_in">rs</span>(p), mid<span class="number">+1</span>, r);</span><br><span class="line"><span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tag[p]=tag[p]+k;</span><br><span class="line">ans[p]=ans[p]+k*(r-l<span class="number">+1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">ls</span>(p), l, mid, tag[p]);</span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">rs</span>(p), mid<span class="number">+1</span>, r, tag[p]);</span><br><span class="line">tag[p]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> nl, <span class="type">int</span> nr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(nl&lt;=l&amp;&amp;r&lt;=nr)</span><br><span class="line">&#123;</span><br><span class="line">ans[p]+=k*(r-l<span class="number">+1</span>);</span><br><span class="line">tag[p]+=k;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">push_down</span>(p, l, r);</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nl&lt;=mid) <span class="built_in">update</span>(nl, nr, l, mid, <span class="built_in">ls</span>(p), k);</span><br><span class="line"><span class="keyword">if</span>(nr&gt;mid) <span class="built_in">update</span>(nl, nr, mid<span class="number">+1</span>, r,<span class="built_in">rs</span>(p), k);</span><br><span class="line"><span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> q_x, <span class="type">int</span> q_y, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(q_x&lt;=l &amp;&amp; r&lt;=q_y) <span class="keyword">return</span> ans[p];</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">push_down</span>(p,l,r);</span><br><span class="line"><span class="keyword">if</span>(q_x&lt;=mid) res+=<span class="built_in">query</span>(q_x, q_y, l, mid, <span class="built_in">ls</span>(p));</span><br><span class="line"><span class="keyword">if</span>(q_y&gt;mid) res+=<span class="built_in">query</span>(q_x, q_y, mid<span class="number">+1</span>, r, <span class="built_in">rs</span>(p));</span><br><span class="line"><span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ttt,b,c,d,e,f;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;ttt;</span><br><span class="line"><span class="keyword">if</span>(ttt==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line"><span class="built_in">update</span>(b,c,<span class="number">1</span>,n,<span class="number">1</span>,d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;e&gt;&gt;f;</span><br><span class="line">cout&lt;&lt;<span class="built_in">query</span>(e,f,<span class="number">1</span>,n,<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://yuzh.tech/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>背包问题</title>
      <link>https://yuzh.tech/posts/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</link>
      <guid>https://yuzh.tech/posts/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</guid>
      <pubDate>Tue, 08 Oct 2024 08:38:02 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;确定状态表示：&lt;code&gt;dp[i][j]&lt;/code&gt;表示在背包容量为j时，从下标为0到i的物品里任意取的最大价值。&lt;/p&gt;
&lt;h2 id=&quot;01背包&quot;&gt;&lt;a href=&quot;#01背包&quot; class=&quot;headerlink&quot; title=&quot;01背包&quot;&gt;&lt;/a&gt;01背包&lt;/h</description>
        
      
      
      
      <content:encoded><![CDATA[<p>确定状态表示：<code>dp[i][j]</code>表示在背包容量为j时，从下标为0到i的物品里任意取的最大价值。</p><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>模板：洛谷<a href="https://www.luogu.com.cn/problem/P1048">P1048</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">item</span>&#123;</span><br><span class="line"><span class="type">int</span> size, value;</span><br><span class="line">&#125;a[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t,m;</span><br><span class="line">cin&gt;&gt;t&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i].size&gt;&gt;a[i].value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=t;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=a[i].size) </span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-a[i].size]+a[i].value);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;dp[m][t];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>先继承上一层状态-&gt;若放得下就与当前行的项进行比较</p><p>模板：洛谷<a href="https://www.luogu.com.cn/problem/P1616">P1616</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=t;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=a[i].size) </span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i][j], dp[i][j-a[i].size]+a[i].value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>利用二进制将多重背包问题转换为01背包问题即可，时间复杂度会降低至原来的对数级别。</p>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://yuzh.tech/posts/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>单调队列</title>
      <link>https://yuzh.tech/posts/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</link>
      <guid>https://yuzh.tech/posts/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</guid>
      <pubDate>Tue, 24 Sep 2024 11:59:58 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;单调队列能够保证最大&amp;#x2F;最小的元素始终出现在队首，同时维持原先数据的顺序。实现单调队列需要用到&lt;code&gt;deque&lt;/code&gt;双向队列。&lt;/p&gt;
&lt;p&gt;每当获取到一个元素时，弹出前方所有比它小的元素，从而保证队列的单调性；每当最大&amp;#x2F;最小元素，即队首离开</description>
        
      
      
      
      <content:encoded><![CDATA[<p>单调队列能够保证最大&#x2F;最小的元素始终出现在队首，同时维持原先数据的顺序。实现单调队列需要用到<code>deque</code>双向队列。</p><p>每当获取到一个元素时，弹出前方所有比它小的元素，从而保证队列的单调性；每当最大&#x2F;最小元素，即队首离开窗口时，则将其弹出队列。</p><p>单调队列可以用于解决滑动窗口问题。</p><h2 id="滑动窗口问题"><a href="#滑动窗口问题" class="headerlink" title="滑动窗口问题"></a>滑动窗口问题</h2><p>有一个长为<code>n</code>的序列<code>a</code>，以及一个大小为<code>k</code>的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。</p><p>本题通过分别生成单调递增队列和单调递减队列得到所需结果。完整代码见下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> id, value;</span><br><span class="line">&#125;node[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line">deque&lt;Node&gt; dq;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;node[i].value;</span><br><span class="line">node[i].id=i;</span><br><span class="line"><span class="keyword">while</span>(dq.<span class="built_in">size</span>()!=<span class="number">0</span> &amp;&amp; node[i].value&lt;dq.<span class="built_in">front</span>().value)</span><br><span class="line">&#123;</span><br><span class="line">dq.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(dq.<span class="built_in">size</span>()!=<span class="number">0</span> &amp;&amp; node[i].value&lt;dq.<span class="built_in">back</span>().value)</span><br><span class="line">&#123;</span><br><span class="line">dq.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line">dq.<span class="built_in">push_back</span>(node[i]);</span><br><span class="line"><span class="keyword">if</span>(i-dq.<span class="built_in">front</span>().id&gt;k<span class="number">-1</span>) dq.<span class="built_in">pop_front</span>();</span><br><span class="line"><span class="keyword">if</span>(i&gt;=k) cout&lt;&lt;dq.<span class="built_in">front</span>().value&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">dq.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">node[i].id=i;</span><br><span class="line"><span class="keyword">while</span>(dq.<span class="built_in">size</span>()!=<span class="number">0</span> &amp;&amp; node[i].value&gt;dq.<span class="built_in">front</span>().value)</span><br><span class="line">&#123;</span><br><span class="line">dq.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(dq.<span class="built_in">size</span>()!=<span class="number">0</span> &amp;&amp; node[i].value&gt;dq.<span class="built_in">back</span>().value)</span><br><span class="line">&#123;</span><br><span class="line">dq.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line">dq.<span class="built_in">push_back</span>(node[i]);</span><br><span class="line"><span class="keyword">if</span>(i-dq.<span class="built_in">front</span>().id&gt;k<span class="number">-1</span>) dq.<span class="built_in">pop_front</span>();</span><br><span class="line"><span class="keyword">if</span>(i&gt;=k) cout&lt;&lt;dq.<span class="built_in">front</span>().value&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附 C++ <code>deque</code> API：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. dq.front():返回的一个元素的引用。</span><br><span class="line">2. dq.back():返回最后一个元素的引用。</span><br><span class="line">3. dq.pop_back():删除尾部的元素。不返回值。</span><br><span class="line">4. dq.pop_front()：删除头部元素。不返回值。</span><br><span class="line">5. dq.push_back(e):在队尾添加一个元素e。</span><br><span class="line">6. dq.push_front(e):在对头添加一个元素e。</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://yuzh.tech/posts/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>最小生成树</title>
      <link>https://yuzh.tech/posts/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link>
      <guid>https://yuzh.tech/posts/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid>
      <pubDate>Sun, 22 Sep 2024 05:50:30 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;最小生成树&quot;&gt;&lt;a href=&quot;#最小生成树&quot; class=&quot;headerlink&quot; title=&quot;最小生成树&quot;&gt;&lt;/a&gt;最小生成树&lt;/h1&gt;&lt;p&gt;模板：&lt;a href=&quot;https://www.luogu.com.cn/problem/P3366&quot;&gt;P3366 </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>模板：<a href="https://www.luogu.com.cn/problem/P3366">P3366 【模板】最小生成树 - 洛谷</a></p><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><ol><li>将任意节点作为根，并找出与之相邻的所有边，获取未获得答案的节点中<code>dis</code>最小的节点(<code>dis</code>用于记录<strong>节点到所有邻接点的最短距离</strong>)</li><li>标记获得的最小节点<code>cur</code>的访问状态为true</li><li>将<code>cur</code>节点的临界点<code>dis</code>值进行更新</li><li>以<code>cur</code>节点作为根继续搜索下一个<code>dis</code>最小的节点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prim</span></span><br><span class="line"><span class="type">bool</span> flag[maxn];</span><br><span class="line"><span class="built_in">memset</span>(flag, <span class="literal">false</span>, <span class="built_in">sizeof</span>(flag));</span><br><span class="line"><span class="type">bool</span> pd=<span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>, dis[maxn];</span><br><span class="line">dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    dis[i]=<span class="number">0x7f7f7f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0x7f7f7f</span>, cur, pnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag[j]==<span class="literal">false</span> &amp;&amp; temp&gt;dis[j])</span><br><span class="line">        &#123;</span><br><span class="line">            temp=dis[j];</span><br><span class="line">            cur=j;</span><br><span class="line">            pnt=edge[j].to;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="number">0x7f7f7f</span>) pd=<span class="literal">true</span>;</span><br><span class="line">    flag[cur]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=head[cur];j!=<span class="number">-1</span>;j=edge[j].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[edge[j].to] &amp;&amp; dis[edge[j].to]&gt;edge[j].weight)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[edge[j].to]=edge[j].weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><ol><li>将边从小到大<strong>排序</strong></li><li>若<strong>没有回路</strong>，则<strong>添加</strong>当前边</li><li>边数达到<strong>n-1</strong>时，最小生成树建成</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.weight&lt;b.weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findroot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">findroot</span>(fa[x]); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">x = <span class="built_in">findroot</span>(x);</span><br><span class="line">y = <span class="built_in">findroot</span>(y);</span><br><span class="line">fa[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123; fa[i]=i; &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line"><span class="built_in">addEdge</span>(u,v,w);</span><br><span class="line"><span class="built_in">addEdge</span>(v,u,w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(edge, edge+m*<span class="number">2</span>, cmp);</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m*<span class="number">2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">findroot</span>(edge[i].from)!=<span class="built_in">findroot</span>(edge[i].to))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Merge</span>(edge[i].from,edge[i].to);</span><br><span class="line">ans+=edge[i].weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://yuzh.tech/posts/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>单源最短路的链式前向星实现</title>
      <link>https://yuzh.tech/posts/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%9A%84%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E5%AE%9E%E7%8E%B0/</link>
      <guid>https://yuzh.tech/posts/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%9A%84%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Sat, 21 Sep 2024 02:08:36 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;算法的原理以及邻接矩阵实现见先前写的&lt;a href=&quot;/posts/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/&quot;&gt;单源最短路径&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;相较于邻接矩阵，邻接矩阵在进行松弛操作时需要遍历每一条</description>
        
      
      
      
      <content:encoded><![CDATA[<p>算法的原理以及邻接矩阵实现见先前写的<a href="/posts/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/">单源最短路径</a>。</p><p>相较于邻接矩阵，邻接矩阵在进行松弛操作时需要遍历每一条边，而基于链式前向星的实现仅需执行出度的个数次，大大节省了循环次数。</p><h1 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h1><p>下方算法中，<code>dist</code>记录了每个节点当前的最短路径，初始值设定为无穷大；<code>flag</code>记录了先前每一轮循环中未确定答案的点中路径最短的点，即已经获得答案的点；<code>p</code>记录了节点的直接前驱。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dijkstra</span></span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[<span class="number">1</span>]; i!=<span class="number">-1</span>; i=edge[i].next)</span><br><span class="line">&#123;</span><br><span class="line">    dist[edge[i].to]=edge[i].weight;</span><br><span class="line">    p[edge[i].to]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0x7f7f7f</span>, t=<span class="number">1</span>; <span class="comment">// t为源点，此处设定为1 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag[j]==<span class="literal">false</span> &amp;&amp; dist[j]&lt;temp)</span><br><span class="line">        &#123;</span><br><span class="line">            temp=dist[j];</span><br><span class="line">            t=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">//无法到达任何一个点 </span></span><br><span class="line">    flag[t]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=head[t]; k!=<span class="number">-1</span>; k=edge[k].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=edge[k].to;</span><br><span class="line">        <span class="keyword">if</span>(flag[j]==<span class="literal">false</span> &amp;&amp; dist[j]&gt;dist[t]+edge[k].weight )</span><br><span class="line">        &#123;</span><br><span class="line">            dist[j]=dist[t]+edge[k].weight;</span><br><span class="line">            p[j]=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆优化Dijkstra"><a href="#堆优化Dijkstra" class="headerlink" title="堆优化Dijkstra"></a>堆优化Dijkstra</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Djikstra + Priority_Queue</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">int</span> dis;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Node &amp;x)<span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x.dis&lt;dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[<span class="number">100010</span>], cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line"><span class="type">int</span> to, weight, next;</span><br><span class="line">&#125;edge[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[cnt].to=v;</span><br><span class="line">edge[cnt].weight=w;</span><br><span class="line">edge[cnt].next=head[u];</span><br><span class="line">head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[<span class="number">100010</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">100010</span>];</span><br><span class="line">priority_queue&lt;Node&gt;q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">dis[s]=<span class="number">0</span>; vis[s]=<span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>((Node)&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cntnode=q.<span class="built_in">top</span>().id;</span><br><span class="line">        <span class="keyword">if</span>(vis[cntnode]) <span class="keyword">continue</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[cntnode]=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[cntnode]; i!=<span class="number">-1</span>; i=edge[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[edge[i].to]&gt;dis[cntnode]+edge[i].weight)</span><br><span class="line">&#123;</span><br><span class="line">dis[edge[i].to]=dis[cntnode]+edge[i].weight;</span><br><span class="line"><span class="keyword">if</span>(!vis[edge[i].to])</span><br><span class="line">&#123;</span><br><span class="line">vis[edge[i].to]=<span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>((Node)&#123;edge[i].to, dis[edge[i].to]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(dis, <span class="number">0x3f3f3f3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line"><span class="built_in">add</span>(u,v,w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dijkstra</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[i]==<span class="number">0x3f3f3f3f</span>) cout&lt;&lt;<span class="string">&quot;NA&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;dis[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h1><p>此处实现中的<code>pd</code>用于判断是否存在<a href="https://www.luogu.com.cn/problem/P3385">负环</a>，其余部分为标准SPFA。</p><p>判断负环的原理：判断<strong>入队次数</strong>是否&gt;&#x3D;n，如果是则说明有负环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dis[maxn], cnt[maxn];</span><br><span class="line"><span class="type">bool</span> inq[maxn], pd=<span class="literal">false</span>;</span><br><span class="line"><span class="built_in">memset</span>(dis, <span class="number">0x3f3f3f3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line"><span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line"><span class="built_in">memset</span>(inq, <span class="literal">false</span>, <span class="built_in">sizeof</span>(inq));</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">    <span class="keyword">if</span>(w&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">addEdge</span>(u,v,w);</span><br><span class="line">        <span class="built_in">addEdge</span>(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">addEdge</span>(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">inq[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cnthead=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>(); inq[cnthead]=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[cnthead];i!=<span class="number">-1</span>;i=edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=edge[i].to, weight=edge[i].weight;</span><br><span class="line">        <span class="keyword">if</span>(dis[to]&gt;dis[cnthead]+weight)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[to]=dis[cnthead]+weight;</span><br><span class="line">            <span class="keyword">if</span>(!inq[to])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(++cnt[to]&gt;=n)</span><br><span class="line">                &#123;</span><br><span class="line">                    pd=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                inq[to]=<span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pd==<span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pd==<span class="literal">true</span>) cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;dis[n]&lt;&lt;endl;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://yuzh.tech/posts/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%9A%84%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>链式前向星</title>
      <link>https://yuzh.tech/posts/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/</link>
      <guid>https://yuzh.tech/posts/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/</guid>
      <pubDate>Sat, 21 Sep 2024 01:54:12 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;链式前向星是一种图的存储方式，相比于邻接矩阵和邻接表，链式前向星是一种&lt;strong&gt;静态链表存储&lt;/strong&gt;，用边集数组和邻接表相结</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>链式前向星是一种图的存储方式，相比于邻接矩阵和邻接表，链式前向星是一种<strong>静态链表存储</strong>，用边集数组和邻接表相结合，可以快速<strong>访问一个顶点的所有邻接点</strong>。</p><p>数据结构详解见<a href="https://www.bilibili.com/video/BV13r4y1X7a4">视频</a>。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>链式前向星存储包括两种结构：</p><ul><li><p>边集数组edge[]：edge[i]表示第i条边;</p></li><li><p>头结点数组head[]：head[i]存以i为起点的第一条边的下标(在edge[]中的下标)。</p></li></ul><p>Edge结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> to;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line"><span class="type">int</span> next;</span><br><span class="line">&#125;edge[maxn*maxn];</span><br></pre></td></tr></table></figure><p>其中，<code>to</code>为当前边的终点，<code>weight</code>为边权，<code>next</code>为当前边终点的兄弟节点，即当前边起点的另外一个邻接点。</p><p>添加边需要通过<code>addEdge(u,v,w);</code>执行，完整数据结构维护代码见下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 10001</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> to;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line"><span class="type">int</span> next;</span><br><span class="line">&#125;edge[maxn*maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[maxn], cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[cnt].to=to;</span><br><span class="line">edge[cnt].weight=weight;</span><br><span class="line">edge[cnt].next=head[from];</span><br><span class="line">head[from]=cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若需访问某个节点u的所有邻接点，使用<code>for</code>循环即可，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[<span class="number">4</span>];i!=<span class="number">-1</span>;i=edge[i].next)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//输出临界点的编号和到这个临界点的边权</span></span><br><span class="line">    cout&lt;&lt;edge[i].to&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;edge[i].weight&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://yuzh.tech/posts/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>线性筛素数</title>
      <link>https://yuzh.tech/posts/%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0/</link>
      <guid>https://yuzh.tech/posts/%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0/</guid>
      <pubDate>Sun, 15 Sep 2024 15:56:58 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;线性筛（欧拉筛）&quot;&gt;&lt;a href=&quot;#线性筛（欧拉筛）&quot; class=&quot;headerlink&quot; title=&quot;线性筛（欧拉筛）&quot;&gt;&lt;/a&gt;线性筛（欧拉筛）&lt;/h2&gt;&lt;p&gt;原理：每个数都被其&lt;strong&gt;最小的质因数&lt;/strong&gt;筛掉&lt;/p&gt;
&lt;figure</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="线性筛（欧拉筛）"><a href="#线性筛（欧拉筛）" class="headerlink" title="线性筛（欧拉筛）"></a>线性筛（欧拉筛）</h2><p>原理：每个数都被其<strong>最小的质因数</strong>筛掉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; prime;</span><br><span class="line"><span class="type">bool</span> mmap[<span class="number">100000001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=a;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(mmap[i]==<span class="literal">false</span>) </span><br><span class="line">&#123;</span><br><span class="line">prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j : prime)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j*i&gt;a) <span class="keyword">break</span>;</span><br><span class="line">mmap[i*j]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(i%j==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mmap[a];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">cout&lt;&lt;!<span class="built_in">isPrime</span>(n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://yuzh.tech/posts/%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>bfs</title>
      <link>https://yuzh.tech/posts/bfs/</link>
      <guid>https://yuzh.tech/posts/bfs/</guid>
      <pubDate>Fri, 13 Sep 2024 06:47:48 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;广度优先算法&quot;&gt;&lt;a href=&quot;#广度优先算法&quot; class=&quot;headerlink&quot; title=&quot;广度优先算法&quot;&gt;&lt;/a&gt;广度优先算法&lt;/h1&gt;&lt;h2 id=&quot;COGS3008-朋友圈&quot;&gt;&lt;a href=&quot;#COGS3008-朋友圈&quot; class=&quot;head</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="广度优先算法"><a href="#广度优先算法" class="headerlink" title="广度优先算法"></a>广度优先算法</h1><h2 id="COGS3008-朋友圈"><a href="#COGS3008-朋友圈" class="headerlink" title="COGS3008 朋友圈"></a>COGS3008 朋友圈</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NOI班有n位学员，因为相处时间有限，有的学员之间加了微信，有的学员之间没有。假设加微信的关系是相互的，即如果a加了b的微信，b也会加a的微信。</span><br><span class="line"></span><br><span class="line">现在有一条NOI班上的爆炸性的新闻从1号学员发出，每个看到这个新闻的NOI班学员都会在朋友圈转发，而加了他微信的朋友都会看到。没有在NOI班上的学员都不会转发（因为和自己关系不大）。</span><br><span class="line"></span><br><span class="line">告诉你NOI班上的学员之间的微信好友关系，请问最终有多少个学员看到这则新闻。</span><br></pre></td></tr></table></figure><p>本题为最基本的BFS应用，每有一个元素<code>i</code>入列，使<code>ans+1</code>，同时标记<code>inq[i]=1</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 10010</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> mmap[MAXN][MAXN], inq[MAXN];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">mmap[x][y]=<span class="literal">true</span>;</span><br><span class="line">mmap[y][x]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">inq[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> hd=Q.<span class="built_in">front</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(mmap[hd][i]==<span class="literal">true</span> &amp;&amp; inq[i]==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">Q.<span class="built_in">push</span>(i);</span><br><span class="line">ans++;</span><br><span class="line">inq[i]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="COGS152-泥潭"><a href="#COGS152-泥潭" class="headerlink" title="COGS152 泥潭"></a>COGS152 泥潭</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Farmer John在早晨6点准时去给贝茜挤奶，然而昨天晚上下了大雨，他的牧场变得泥泞不堪了。Farmer John的家在坐标平面的 (0,0) 处，贝茜在 (X, Y) (-500 ≤ X ≤ 500; -500 ≤ Y ≤ 500)。他看见了所有的 N  (1 ≤ N ≤ 10,000) 个泥潭，分别在 (Ai, Bi) (-500 ≤ Ai ≤ 500; -500 ≤ Bi ≤ 500) 。每个泥潭只占一个点的位置。</span><br><span class="line"></span><br><span class="line">Farmer John 刚刚买了新的靴子，他绝对不想把靴子踩进泥潭弄脏，而他又想尽快的找到贝茜。他已经快晚了，因为他花了大量的时间来找到所有的泥潭的位置。 Farmer John 只能平行于坐标轴移动，每次移动一个单位。请你帮助 Farmer John 找到一条路，使得 Farmer John 能够最快的找到贝茜，而且不会弄脏靴子。我们约定一定存在一条路使 Farmer John 找到贝茜。</span><br></pre></td></tr></table></figure><p>本题使用结构体记录当前深度，从而得以满足题意</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1010</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dirx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> diry[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x,y,step;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> mud[MAXN][MAXN], inq[MAXN][MAXN];</span><br><span class="line">queue&lt;cor&gt;Q;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> orix,oriy,n;</span><br><span class="line">cin&gt;&gt;orix&gt;&gt;oriy&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">mud[a<span class="number">+500</span>][b<span class="number">+500</span>]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Q.<span class="built_in">push</span>(&#123;orix<span class="number">+500</span>,oriy<span class="number">+500</span>,<span class="number">0</span>&#125;);</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line">inq[orix<span class="number">+500</span>][oriy<span class="number">+500</span>]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cor cur=Q.<span class="built_in">front</span>();</span><br><span class="line"><span class="keyword">if</span>(cur.x==<span class="number">500</span>&amp;&amp;cur.y==<span class="number">500</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> newx=cur.x+dirx[i], newy=cur.y+diry[i];</span><br><span class="line"><span class="keyword">if</span>(newx&gt;=<span class="number">0</span>&amp;&amp;newx&lt;=<span class="number">1000</span> &amp;&amp; newy&gt;=<span class="number">0</span>&amp;&amp;newy&lt;=<span class="number">1000</span> &amp;&amp; inq[newx][newy]==<span class="literal">false</span> &amp;&amp; mud[newx][newy]==<span class="literal">false</span> )</span><br><span class="line">&#123;</span><br><span class="line">Q.<span class="built_in">push</span>(&#123;newx, newy, cur.step<span class="number">+1</span>&#125;);</span><br><span class="line">inq[newx][newy]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;Q.<span class="built_in">front</span>().step;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="洛谷P1949-聪明的打字员"><a href="#洛谷P1949-聪明的打字员" class="headerlink" title="洛谷P1949 聪明的打字员"></a>洛谷P1949 聪明的打字员</h2><p>题目待做，之后补全。</p>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://yuzh.tech/posts/bfs/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>单源最短路径</title>
      <link>https://yuzh.tech/posts/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</link>
      <guid>https://yuzh.tech/posts/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</guid>
      <pubDate>Fri, 09 Aug 2024 03:35:06 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;模板：洛谷&lt;a href=&quot;https://www.luogu.com.cn/problem/P3371&quot;&gt;P3371 单源最短路径（弱化版）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Bell-man-Ford算法&quot;&gt;&lt;a href=&quot;#Bell-man-Ford算法&quot; class</description>
        
      
      
      
      <content:encoded><![CDATA[<p>模板：洛谷<a href="https://www.luogu.com.cn/problem/P3371">P3371 单源最短路径（弱化版）</a></p><h2 id="Bell-man-Ford算法"><a href="#Bell-man-Ford算法" class="headerlink" title="Bell-man Ford算法"></a>Bell-man Ford算法</h2><p>在每一轮对每个点进行松弛，即比较<strong>目标点当前的最短路径</strong>和<strong>出发点最短路径与边权相加</strong>的值，取最小值作为最短路径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> edg[<span class="number">100010</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> D[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(D,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(D));</span><br><span class="line">D[v]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(D[edg[j][<span class="number">1</span>]]&gt;D[edg[j][<span class="number">0</span>]]+edg[j][<span class="number">2</span>])</span><br><span class="line">D[edg[j][<span class="number">1</span>]]=D[edg[j][<span class="number">0</span>]]+edg[j][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;D[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h2><p>设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点hd，并且用hd点当前的最短路径估计值对离开hd点所指向的结点to_node进行松弛操作，如果to_node点的最短路径估计值有所调整，且to_node点不在当前的队列中，就将to_node点放入队尾。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(D,<span class="number">0x7f7f7f7f</span>,<span class="built_in">sizeof</span>(D));</span><br><span class="line">D[root]=<span class="number">0</span>;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;Q;</span><br><span class="line">Q.<span class="built_in">push</span>(root);</span><br><span class="line">inq[root]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当队列不为空</span></span><br><span class="line"><span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> hd=Q.<span class="built_in">front</span>();<span class="comment">//取出队首节点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M[hd].<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">edg e=M[hd][i];</span><br><span class="line"><span class="keyword">if</span>(D[e.to_node]&gt;D[hd]+e.value)</span><br><span class="line">&#123;</span><br><span class="line">D[e.to_node]=D[hd]+e.value;</span><br><span class="line"><span class="keyword">if</span>(inq[e.to_node]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">inq[e.to_node]=<span class="literal">true</span>;</span><br><span class="line">Q.<span class="built_in">push</span>(e.to_node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">inq[hd]=<span class="number">0</span>;</span><br><span class="line">Q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;D[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>用于求解<strong>非负权图</strong>上单源最短路径的算法。从起始点开始，采用贪心算法的策略，<em>每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止</em>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;edg&gt;M[maxn];</span><br><span class="line"><span class="type">int</span> D[maxn],used[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">djs</span><span class="params">(<span class="type">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(D,<span class="number">0x7f7f7f7f</span>,<span class="built_in">sizeof</span>(D));</span><br><span class="line">D[root]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mx=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(used[mx]==<span class="literal">true</span> &amp;&amp; mx&lt;=n) mx++;<span class="comment">//找到未被使用的点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(used[j]==<span class="literal">false</span> &amp;&amp; D[mx]&gt;D[j])</span><br><span class="line">&#123;</span><br><span class="line">mx=j;<span class="comment">//定位到第一个没有被确认的点 </span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">used[mx]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;M[mx].<span class="built_in">size</span>();j++)</span><br><span class="line">&#123;</span><br><span class="line">edg e=M[mx][j];</span><br><span class="line"><span class="keyword">if</span>(D[e.to_node]&gt;D[mx]+e.value)</span><br><span class="line">&#123;</span><br><span class="line">D[e.to_node]=D[mx]+e.value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;D[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><p>定义一个数组 <code>f[k][x][y]</code>，表示只允许经过结点<code>1</code>到 <code>k</code>，结点<code>x</code>到结点<code>y</code>的最短路长度。</p><p>容易得到状态转移方程：<code>f[k][x][y] = min(f[k-1][x][y], f[k-1][x][k]+f[k-1][k][y])</code>，而因为第一维对结果无影响，可以省略，故得到状态转移方程：<code>f[x][y] = min(f[x][y], f[x][k]+f[k][y])</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 110</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i!=j)</span><br><span class="line">ans[i][j]=<span class="number">0x7f7f7f7f</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">ans[u][v]=<span class="built_in">min</span>(ans[u][v], w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">1</span>;y&lt;=n;y++)</span><br><span class="line">&#123;</span><br><span class="line">ans[x][y]=<span class="built_in">min</span>(ans[x][y], ans[x][k]+ans[k][y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;ans[s][i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://yuzh.tech/posts/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>二叉查找树</title>
      <link>https://yuzh.tech/posts/BinarySearchTree/</link>
      <guid>https://yuzh.tech/posts/BinarySearchTree/</guid>
      <pubDate>Wed, 07 Aug 2024 14:58:34 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;基本实现&quot;&gt;&lt;a href=&quot;#基本实现&quot; class=&quot;headerlink&quot; title=&quot;基本实现&quot;&gt;&lt;/a&gt;基本实现&lt;/h2&gt;&lt;h3 id=&quot;节点定义&quot;&gt;&lt;a href=&quot;#节点定义&quot; class=&quot;headerlink&quot; title=&quot;节点定义&quot;&gt;&lt;/a</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><h3 id="节点定义"><a href="#节点定义" class="headerlink" title="节点定义"></a>节点定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val; <span class="comment">//Öµ </span></span><br><span class="line">Node *lefttree,*righttree;<span class="comment">//×ó×ÓÊ÷£¬ÓÒ×ÓÊ÷</span></span><br><span class="line">&#125;;</span><br><span class="line">Node *root=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Node *&amp;node, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">node = <span class="keyword">new</span> Node;</span><br><span class="line">node-&gt;val=val;</span><br><span class="line">node-&gt;lefttree = node-&gt;righttree = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;val==val) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;val&gt;val) <span class="built_in">insert</span>(node-&gt;lefttree, val);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">insert</span>(node-&gt;righttree, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(Node *&amp;node, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;val==val) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;val&gt;val) <span class="built_in">search</span>(node-&gt;lefttree, val);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">search</span>(node-&gt;righttree, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取最大值节点和最小值节点"><a href="#获取最大值节点和最小值节点" class="headerlink" title="获取最大值节点和最小值节点"></a>获取最大值节点和最小值节点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">max</span><span class="params">(Node *&amp;node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;righttree==<span class="literal">NULL</span>) <span class="keyword">return</span> node;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">return</span>(<span class="built_in">max</span>(node-&gt;righttree));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">min</span><span class="params">(Node *&amp;node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;lefttree==<span class="literal">NULL</span>) <span class="keyword">return</span> node;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">return</span>(<span class="built_in">max</span>(node-&gt;lefttree));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(Node *&amp;node, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;val==val)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;lefttree==<span class="literal">NULL</span> &amp;&amp; node-&gt;righttree==<span class="literal">NULL</span>) node=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;lefttree!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">Node *pre=<span class="built_in">max</span>(node-&gt;lefttree);</span><br><span class="line">node-&gt;val=pre-&gt;val;</span><br><span class="line"><span class="built_in">del</span>(node-&gt;lefttree, pre-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;righttree!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">Node *aft=<span class="built_in">min</span>(node-&gt;righttree);</span><br><span class="line">node-&gt;val=aft-&gt;val;</span><br><span class="line"><span class="built_in">del</span>(node-&gt;righttree, aft-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;val&gt;val) <span class="built_in">del</span>(node-&gt;lefttree, val);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">del</span>(node-&gt;righttree, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">insert</span>(root, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">insert</span>(root,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">insert</span>(root,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">insert</span>(root,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//cout&lt;&lt;root-&gt;righttree-&gt;val;</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;search(root,3);</span></span><br><span class="line"><span class="built_in">del</span>(root,<span class="number">4</span>);</span><br><span class="line">cout&lt;&lt;<span class="built_in">max</span>(root)-&gt;val;</span><br><span class="line">cout&lt;&lt;<span class="built_in">min</span>(root)-&gt;val;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p><strong>最优情况下</strong>：二叉搜索树为完全二叉树（或者接近完全二叉树），其平均比较次数为：log(N)。</p><p><strong>最差情况下</strong>：二叉搜索树退化为单支树（或者类似单支），其平均比较次数为 N。</p><p>因此，需要使用<strong>平衡二叉树</strong>来确保查找、插入和删除的时间复杂度为O(log n)。</p>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://yuzh.tech/posts/BinarySearchTree/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>链表与下压堆栈</title>
      <link>https://yuzh.tech/posts/linkedlist/</link>
      <guid>https://yuzh.tech/posts/linkedlist/</guid>
      <pubDate>Tue, 06 Aug 2024 10:37:13 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h1&gt;&lt;h2 id=&quot;节点记录&quot;&gt;&lt;a href=&quot;#节点记录&quot; class=&quot;headerlink&quot; title=&quot;节点记录&quot;&gt;&lt;/a&gt;节点记录&lt;/h</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="节点记录"><a href="#节点记录" class="headerlink" title="节点记录"></a>节点记录</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> item;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="构造链表"><a href="#构造链表" class="headerlink" title="构造链表"></a>构造链表</h2><p>为每个元素创造节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node *first=<span class="keyword">new</span> Node;</span><br><span class="line">Node *second=<span class="keyword">new</span> Node;</span><br><span class="line">Node *third=<span class="keyword">new</span> Node;</span><br></pre></td></tr></table></figure><p>将每个结点的item域设为所需的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first-&gt;item=<span class="string">&quot;to&quot;</span>;</span><br><span class="line">second-&gt;item=<span class="string">&quot;be&quot;</span>;</span><br><span class="line">third-&gt;item=<span class="string">&quot;or&quot;</span></span><br></pre></td></tr></table></figure><p>设置next域来构造链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first-&gt;next=second;</span><br><span class="line">second-&gt;next=third;</span><br></pre></td></tr></table></figure><h1 id="下压堆栈-LIFO"><a href="#下压堆栈-LIFO" class="headerlink" title="下压堆栈(LIFO)"></a>下压堆栈(LIFO)</h1><h2 id="在表头插入节点"><a href="#在表头插入节点" class="headerlink" title="在表头插入节点"></a>在表头插入节点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node *newNode=<span class="keyword">new</span> Node;</span><br><span class="line">newNode-&gt;item=item;</span><br><span class="line">newNode-&gt;next=first;</span><br><span class="line">first=newNode;</span><br><span class="line">N++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从表头删除节点"><a href="#从表头删除节点" class="headerlink" title="从表头删除节点"></a>从表头删除节点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> item=first-&gt;item;</span><br><span class="line">first=first-&gt;next;</span><br><span class="line">N--;</span><br><span class="line"><span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历链表"><a href="#遍历链表" class="headerlink" title="遍历链表"></a>遍历链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Node *x=first;x!=<span class="literal">NULL</span>;x=x-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//处理x-&gt;item</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> item;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node *first = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node *newNode=<span class="keyword">new</span> Node;</span><br><span class="line">newNode-&gt;item=item;</span><br><span class="line">newNode-&gt;next=first;</span><br><span class="line">first=newNode;</span><br><span class="line">N++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> item=first-&gt;item;</span><br><span class="line">first=first-&gt;next;</span><br><span class="line">N--;</span><br><span class="line"><span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">push</span>(<span class="number">1</span>);<span class="built_in">push</span>(<span class="number">3</span>);<span class="built_in">push</span>(<span class="number">2</span>);<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span>(Node *x=first;x!=<span class="literal">NULL</span>;x=x-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</category>
      
      
      <comments>https://yuzh.tech/posts/linkedlist/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C++ Vector</title>
      <link>https://yuzh.tech/posts/vector/</link>
      <guid>https://yuzh.tech/posts/vector/</guid>
      <pubDate>Tue, 06 Aug 2024 03:33:17 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;定义方式&quot;&gt;&lt;a href=&quot;#定义方式&quot; class=&quot;headerlink&quot; title=&quot;定义方式&quot;&gt;&lt;/a&gt;定义方式&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;/*数据类型*/&gt;<span class="comment">/*名称*/</span>(<span class="type">int</span> nSize);</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;vec;</span><br></pre></td></tr></table></figure><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p><code>vec.push_back()</code> 在动态数组最后插入一个新的元素</p><p><code>vec.pop_back()</code> 删除动态数组最后一个元素</p>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E5%B9%B2%E8%B4%A7/">干货</category>
      
      
      <comments>https://yuzh.tech/posts/vector/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>哈夫曼编码</title>
      <link>https://yuzh.tech/posts/hoffman/</link>
      <guid>https://yuzh.tech/posts/hoffman/</guid>
      <pubDate>Mon, 05 Aug 2024 15:00:52 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;不出现歧义的情况下编出来的码长度最短&lt;/p&gt;
&lt;p&gt;让出现次数多的字符编码最短&lt;/p&gt;
&lt;p&gt;每次合并最小的两个，即生成一个父节点，使得父节点的值为两个子节点的值之和&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/hoffman/hoffman.png&quot; alt=&quot;hof</description>
        
      
      
      
      <content:encoded><![CDATA[<p>不出现歧义的情况下编出来的码长度最短</p><p>让出现次数多的字符编码最短</p><p>每次合并最小的两个，即生成一个父节点，使得父节点的值为两个子节点的值之和</p><p><img src="/posts/hoffman/hoffman.png" alt="hoffman"></p>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://yuzh.tech/posts/hoffman/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>排序算法综合</title>
      <link>https://yuzh.tech/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%BB%BC%E5%90%88/</link>
      <guid>https://yuzh.tech/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%BB%BC%E5%90%88/</guid>
      <pubDate>Sun, 04 Aug 2024 12:42:23 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;下方所有除使用STL库外的所有排序算法调用方法都是&lt;code&gt;qsort(a,0,n-1);&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;初级排序算法&quot;&gt;&lt;a href=&quot;#初级排序算法&quot; class=&quot;headerlink&quot; title=&quot;初级排序算法&quot;&gt;&lt;/a&gt;初级排序算法&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>下方所有除使用STL库外的所有排序算法调用方法都是<code>qsort(a,0,n-1);</code></p><h1 id="初级排序算法"><a href="#初级排序算法" class="headerlink" title="初级排序算法"></a>初级排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubblesort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=right;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;arr[j]) <span class="built_in">swap</span>(arr[i],arr[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionsort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> min=i; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=right;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&lt;arr[min]) min=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(arr[i],arr[min]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>同整理扑克牌，依次将每个元素插入到前面有序的部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionsort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cnt=arr[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=left &amp;&amp; cnt&lt;=arr[j];j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[j],arr[j<span class="number">+1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化：可以利用折半查找的方法找到插入的位置，即折半插入排序</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>通过给定间隔<code>h</code>，使得原来的数组被切分为更小的数组，进而提升插入排序效率</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellsort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> h=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(h&lt;(right-left<span class="number">+1</span>)/<span class="number">3</span>) h=h*<span class="number">3</span><span class="number">+1</span>;</span><br><span class="line"><span class="keyword">while</span>(h&gt;=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;(right-left<span class="number">+1</span>)/h;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cnt=arr[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i-h;j&gt;=left &amp;&amp; cnt&lt;=arr[j];j-=h)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[j],arr[j+h]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">h/=<span class="number">3</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="进阶排序算法"><a href="#进阶排序算法" class="headerlink" title="进阶排序算法"></a>进阶排序算法</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> aux[<span class="number">10000</span>], mid=(left+right)/<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> i=left, j=mid<span class="number">+1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=left; k&lt;=right; k++)</span><br><span class="line">&#123;</span><br><span class="line">aux[k]=arr[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=left;k&lt;=right;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;mid) arr[k]=aux[j++];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(j&gt;right) arr[k]=aux[i++];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(aux[j]&lt;aux[i]) arr[k]=aux[j++];</span><br><span class="line"><span class="keyword">else</span> arr[k]=aux[i++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">mergesort</span>(arr, left, mid);</span><br><span class="line"><span class="built_in">mergesort</span>(arr, mid<span class="number">+1</span>, right);</span><br><span class="line"><span class="built_in">merge</span>(arr, left, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul><li><code>partition</code>函数：以当前给定集合的第一个元素<code>pivot</code>作为基准，比其小的放在左边，比其大的放在右边</li><li>随后对<code>pivot</code>左右的数组分别进行排序，直至<code>left=right</code>结束分治</li></ul><h3 id="手写快排"><a href="#手写快排" class="headerlink" title="手写快排"></a>手写快排</h3><ul><li>可参考(全网最清晰快速排序)[<a href="https://www.bilibili.com/video/BV1vP411g7J3]">https://www.bilibili.com/video/BV1vP411g7J3]</a></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> pivot=arr[left];</span><br><span class="line"><span class="keyword">while</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right &amp;&amp; arr[right]&gt;=pivot)</span><br><span class="line">right--;</span><br><span class="line">arr[left]=arr[right];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left&lt;right &amp;&amp; arr[left]&lt;=pivot)</span><br><span class="line">left++;</span><br><span class="line">arr[right]=arr[left];</span><br><span class="line">&#125;</span><br><span class="line">arr[left]=pivot; <span class="comment">//arr[right]=pivot;</span></span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left&lt;right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> pivot=<span class="built_in">partition</span>(arr,left,right);</span><br><span class="line"><span class="built_in">qsort</span>(arr,left,pivot<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">qsort</span>(arr,pivot<span class="number">+1</span>,right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="STL-sort"><a href="#STL-sort" class="headerlink" title="STL sort"></a>STL sort</h3><p>排序规则</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用：sort(a,a+n,cmp);</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&lt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>https://yuzh.tech/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%BB%BC%E5%90%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>NexT, Hello World!</title>
      <link>https://yuzh.tech/posts/NexT_hello_world/</link>
      <guid>https://yuzh.tech/posts/NexT_hello_world/</guid>
      <pubDate>Wed, 31 Jul 2024 16:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;博客全新改版&quot;&gt;&lt;a href=&quot;#博客全新改版&quot; class=&quot;headerlink&quot; title=&quot;博客全新改版&quot;&gt;&lt;/a&gt;博客全新改版&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;更换主题为NexT&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;更换域名为&lt;a href=&quot;http</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="博客全新改版"><a href="#博客全新改版" class="headerlink" title="博客全新改版"></a>博客全新改版</h1><ul><li><p>更换主题为NexT</p></li><li><p>更换域名为<a href="https://yuzh.tech/">yuzh.tech</a></p></li></ul>]]></content:encoded>
      
      
      
      
      <comments>https://yuzh.tech/posts/NexT_hello_world/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>基于Schtasks的自动打铃机使用教程</title>
      <link>https://yuzh.tech/posts/Automatic_Ring/</link>
      <guid>https://yuzh.tech/posts/Automatic_Ring/</guid>
      <pubDate>Mon, 04 Apr 2022 00:00:00 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;脚本已开源在&lt;a href=&quot;https://github.com/yuzh0816/tools/tree/master/RING&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1M34y147U1/&quot;&gt;视频教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>脚本已开源在<a href="https://github.com/yuzh0816/tools/tree/master/RING">Github</a></p></blockquote><blockquote><p><a href="https://www.bilibili.com/video/BV1M34y147U1/">视频教程</a></p></blockquote><span id="more"></span><p><strong>注意！！请将本文件夹(“RING”)放置于C盘根目录！！</strong></p><p><strong>建议使用Windows Media Player作为音频文件默认打开方式！</strong></p><h2 id="一、启用打铃功能"><a href="#一、启用打铃功能" class="headerlink" title="一、启用打铃功能"></a>一、启用打铃功能</h2><ol><li><p>点击“启用计划任务”<br> Tips：可能会提醒密码，如果电脑有密码就输入电脑密码<br> 如果设置了微软账户请<br> a. 尝试输入微软账户密码而不是PIN<br> b. 直接回车<br> 如果提示”成功设定计划任务”即代表成功。</p></li><li><p>进入“声卡驱动安装”文件夹，点击VBCABLE_Setup_x64.exe，安装好后执行第三步</p></li><li><p>双击“启用虚拟声卡”</p></li><li><p>进入腾讯会议，将麦克风设置为默认设备</p></li><li><p>将扬声器设置为默认扬声器（通常为“扬声器（High Definition Audio Device）”）</p></li><li><p>打开麦克风</p></li></ol><h2 id="二、关闭打铃功能"><a href="#二、关闭打铃功能" class="headerlink" title="二、关闭打铃功能"></a>二、关闭打铃功能</h2><ol><li>双击“恢复如初”即可</li></ol><h2 id="三、关闭打铃功能后想再打开怎么办"><a href="#三、关闭打铃功能后想再打开怎么办" class="headerlink" title="三、关闭打铃功能后想再打开怎么办"></a>三、关闭打铃功能后想再打开怎么办</h2><ol><li>参照第一大点重新操作一遍即可</li></ol>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E5%B9%B2%E8%B4%A7/">干货</category>
      
      
      <comments>https://yuzh.tech/posts/Automatic_Ring/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>UsbEAM Hosts Editor 汉化版</title>
      <link>https://yuzh.tech/posts/usbeam/</link>
      <guid>https://yuzh.tech/posts/usbeam/</guid>
      <pubDate>Wed, 17 Mar 2021 14:52:13 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;原作者博客链接&quot;&gt;&lt;a href=&quot;#原作者博客链接&quot; class=&quot;headerlink&quot; title=&quot;原作者博客链接&quot;&gt;&lt;/a&gt;原作者博客链接&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.dogfight360.com/blog/475/&quot;&gt;羽翼</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="原作者博客链接"><a href="#原作者博客链接" class="headerlink" title="原作者博客链接"></a>原作者博客链接</h2><p><a href="https://www.dogfight360.com/blog/475/">羽翼城个人博客</a></p><h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p>解压并直接打开即可</p><h2 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h2><p>点击此处：<a href="https://yuzh.lanzoui.com/iaBhpn5yyta">蓝奏云</a></p>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E8%BD%AF%E4%BB%B6/">软件</category>
      
      
      <comments>https://yuzh.tech/posts/usbeam/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>安装Paragon ExtFS</title>
      <link>https://yuzh.tech/posts/paragon_extfs/</link>
      <guid>https://yuzh.tech/posts/paragon_extfs/</guid>
      <pubDate>Wed, 17 Feb 2021 06:41:13 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;安装方法&quot;&gt;&lt;a href=&quot;#安装方法&quot; class=&quot;headerlink&quot; title=&quot;安装方法&quot;&gt;&lt;/a&gt;安装方法&lt;/h2&gt;&lt;p&gt;把keygen和另外两个文件放到ExtFS的安装目录下&lt;/p&gt;
&lt;p&gt;打开keygen，先点击Patch RSA 2048，</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p>把keygen和另外两个文件放到ExtFS的安装目录下</p><p>打开keygen，先点击Patch RSA 2048，选择安装目录下的Paragon ExtFS for Windows.exe</p><p>再次点击 Patch RSA 2048，选择安装目录下的extservice.exe</p><p>点击Generate让生成注册码，keygen会自动破解并重启ExtFS的服务。</p><h2 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h2><p><a href="https://china.paragon-software.com/home-windows/extfs-for-windows/download.html">点此进入官网下载主程序</a></p><p><a href="https://yuzh.lanzoui.com/iPjQ5lkjx9c">点此下载Patch</a></p>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E8%BD%AF%E4%BB%B6/">软件</category>
      
      
      <comments>https://yuzh.tech/posts/paragon_extfs/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>STL库 QUEUE入门</title>
      <link>https://yuzh.tech/posts/c++_queue/</link>
      <guid>https://yuzh.tech/posts/c++_queue/</guid>
      <pubDate>Tue, 03 Nov 2020 14:02:53 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/yuzh0816/yuzh0816.github.io/posts/c++_queue/1.jpg&quot; alt=&quot;Queue&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; c</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/yuzh0816/yuzh0816.github.io/posts/c++_queue/1.jpg" alt="Queue"></p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ol><li><p>入队(push):在队列末尾加入一个元素，例如:q.push(x)</p></li><li><p>出队(pop):删除&#x2F;弹出队列第一个元素，即队首元素，例如:q.pop()</p></li><li><p>访问队首元素(front):返回队列第一个元素，例如:q.front()</p></li><li><p>访问队尾元素(back):返回队列最后一个元素，即队尾元素，例如:q.back()</p></li><li><p>判断队列空(empty):判断队列是否为空，如果空，则返回true，否则返回false，例如:q.empty()</p></li><li><p>访问队列中元素的个数(size):返回队列元素个数，例如:q.size()</p></li></ol>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E7%A7%91%E6%99%AE/">科普</category>
      
      
      <comments>https://yuzh.tech/posts/c++_queue/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SP18666 UVA1 - Radiation</title>
      <link>https://yuzh.tech/posts/SP18666/</link>
      <guid>https://yuzh.tech/posts/SP18666/</guid>
      <pubDate>Tue, 06 Oct 2020 15:21:14 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/SP18666&quot;&gt;本题网址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数据点题目给得不好啊，可以&lt;a href=&quot;https://www.luogu.com.cn/paste/kpiv47sn&quot;&gt;参考这里&lt;/a&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="https://www.luogu.com.cn/problem/SP18666">本题网址</a></p><p>数据点题目给得不好啊，可以<a href="https://www.luogu.com.cn/paste/kpiv47sn">参考这里</a></p><span id="more"></span><h2 id="输入样例解释"><a href="#输入样例解释" class="headerlink" title="输入样例解释"></a>输入样例解释</h2><p>这道题会无限读入Case，需要while循环来判断最后输入的“0”</p><p>一个case会出现这样的数据：</p><p>1 表示房屋数量n个</p><p>2 - n+1 表示房屋地址</p><p>n+2 输入两个核电站坐标并给出影响半径的个数k</p><p>n+3 - n+2+k 给出两个核电站的影响半径</p><p>之后的Case同样继续读入，直到输入“0”时停止读入</p><h2 id="输出样例解释"><a href="#输出样例解释" class="headerlink" title="输出样例解释"></a>输出样例解释</h2><p>输出数据格式很简单，直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Case 1:</span><br><span class="line">..</span><br><span class="line">..</span><br><span class="line">..</span><br><span class="line">Case 2:</span><br><span class="line">..</span><br><span class="line">..</span><br><span class="line">..</span><br><span class="line">..</span><br></pre></td></tr></table></figure><h2 id="本题思路"><a href="#本题思路" class="headerlink" title="本题思路"></a>本题思路</h2><p>这是一道模拟题，难度一般，用心做能做出来</p><p>先是while无限输入，然后读入房屋坐标和加油站坐标，直接记录好每个房屋和两个加油站的距离，剪枝优化。这样的话可以避免之后每个循环进行计算。然后对距离进行排序，可以方便计算与半径的距离并且快速舍去后续没有必要的计算。</p><p>接着是暴力比较半径的大小，是的话ans++</p><p>接下来看代码</p><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,xx1[<span class="number">200001</span>],yy1[<span class="number">200001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ress1,ress2;</span><br><span class="line">&#125;ak[<span class="number">200001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pp a,pp b)</span> </span>&#123; <span class="comment">//结构体排序</span></span><br><span class="line"><span class="keyword">if</span>(a.ress1!=b.ress1) &#123;</span><br><span class="line"><span class="keyword">return</span> a.ress1&lt;b.ress1;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> a.ress2&lt;=b.ress2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> hx1,hy1,r1,hx2,hy2,r2;</span><br><span class="line"><span class="comment">//hx1,hy1,r1分别为第一个核电站的横坐标、纵坐标和影响半径 hy1,hy2同理</span></span><br><span class="line"><span class="type">int</span> cases,ans,casejl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">while</span>(n!=<span class="number">0</span>)<span class="comment">//进入无限循环</span></span><br><span class="line">&#123;</span><br><span class="line">casejl++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Case %d:\n&quot;</span>,casejl);<span class="comment">//输出Case个数</span></span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;xx1[i],&amp;yy1[i]);</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;hx1&gt;&gt;hy1&gt;&gt;hx2&gt;&gt;hy2;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">ak[j].ress1=(xx1[j]-hx1)*(xx1[j]-hx1)+(yy1[j]-hy1)*(yy1[j]-hy1);<span class="comment">//两点坐标距离公式</span></span><br><span class="line">ak[j].ress2=(xx1[j]-hx2)*(xx1[j]-hx2)+(yy1[j]-hy2)*(yy1[j]-hy2);</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;cases;</span><br><span class="line"><span class="built_in">sort</span>(ak<span class="number">+1</span>,ak<span class="number">+1</span>+n,cmp);<span class="comment">//排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cases;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;r1,&amp;r2);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ak[j].ress1&lt;=r1*r1 &amp;&amp; ak[j].ress2&lt;=r2*r2)</span><br><span class="line">&#123;</span><br><span class="line">ans++;<span class="comment">//输出答案</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ak[j].ress1&gt;r1*r1 &amp;&amp; ak[j].ress2&gt;r2*r2)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//因为排序过，可以直接跳过</span></span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);<span class="comment">//输出本轮答案</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="本题难点"><a href="#本题难点" class="headerlink" title="本题难点"></a>本题难点</h2><ol><li>题目中的输入数据需要自己猜测（PS：这题目有毒吧。。）</li><li>排序优化</li><li>注意细节</li></ol><h2 id="题后小结"><a href="#题后小结" class="headerlink" title="题后小结"></a>题后小结</h2><p>第一个做出这题的是同学@TheUknownCreator，为我提供了题意解读，感谢帮助。顺便提醒此题没有必要进行快读，scanf速度足够解决本题。</p><p>顺便提供一下我和他一起编写出的<a href="https://www.luogu.com.cn/paste/hcnhp8t7">补充数据</a></p>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E9%A2%98%E8%A7%A3/">题解</category>
      
      
      <comments>https://yuzh.tech/posts/SP18666/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Mark</title>
      <link>https://yuzh.tech/posts/mark/</link>
      <guid>https://yuzh.tech/posts/mark/</guid>
      <pubDate>Tue, 14 Jul 2020 13:20:39 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;ol&gt;
&lt;li&gt;Dijkstra(单源最短路径)&lt;/li&gt;
&lt;li&gt;P4779  &lt;a href=&quot;https://www.luogu.com.cn/problem/P4779&quot;&gt;【模板】单源最短路径（标准版）&lt;/a&gt;&lt;/li&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><ol><li>Dijkstra(单源最短路径)</li><li>P4779  <a href="https://www.luogu.com.cn/problem/P4779">【模板】单源最短路径（标准版）</a></li></ol>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E8%AE%A1%E5%88%92%E8%A1%A8/">计划表</category>
      
      
      <comments>https://yuzh.tech/posts/mark/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>P5076 【深基16.例7】普通二叉树（简化版）</title>
      <link>https://yuzh.tech/posts/P5076/</link>
      <guid>https://yuzh.tech/posts/P5076/</guid>
      <pubDate>Fri, 10 Jul 2020 13:21:14 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/07/09/tQagoDJYXp53h7x.png&quot; alt=&quot;题目&quot;&gt;&lt;/p&gt;
&lt;p&gt;不多赘述，直接看代码吧&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://i.loli.net/2020/07/09/tQagoDJYXp53h7x.png" alt="题目"></p><p>不多赘述，直接看代码吧</p><span id="more"></span><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r,sum;<span class="comment">//l,r为左右节点的号码，sum为该节点作为子树的数量</span></span><br><span class="line">    <span class="type">int</span> val,cnt;<span class="comment">//值，出现次数</span></span><br><span class="line">&#125;ltt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> lst=<span class="number">0</span>,root; <span class="comment">//lst最后一个节点的位置，控制ltt，root为根（ltt的位置，开始时不存在）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//预定义宏，懒人专用。</span></span><br><span class="line"><span class="comment">//ltt中的x随着ls中的x变化而变化</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls(x) ltt[x].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(x) ltt[x].r</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(Node &amp;f,Node ls,Node rs)</span><span class="comment">//insert后的操作（提升操作）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f.sum=f.cnt+ls.sum+rs.sum;<span class="comment">//重复次数加上左右节点的数值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//动态开点（点为0，直接开点）</span></span><br><span class="line">    <span class="keyword">if</span>(!p)<span class="comment">//节点编号为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        p=++lst;<span class="comment">//root=+lst</span></span><br><span class="line">        ltt[p].val=x; ltt[p].cnt=<span class="number">1</span>; ltt[p].sum=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ltt[p].val==x)<span class="comment">//重复情况，数值加一</span></span><br><span class="line">    &#123;</span><br><span class="line">        ltt[p].cnt++; ltt[p].sum++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ltt[p].val&lt;x)<span class="comment">//要插入的点比这个点的数值要大</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">rs</span>(p),x);<span class="comment">//向右跑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//相反后同上</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">ls</span>(p),x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">up</span>(ltt[p],ltt[<span class="built_in">ls</span>(p)],ltt[<span class="built_in">rs</span>(p)]);<span class="comment">//IMPORTANT提升操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findth</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x)</span><span class="comment">//查看某一个点(x)的排名</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//p不存在（空节点），排名为一</span></span><br><span class="line">    <span class="type">int</span> cc=ltt[<span class="built_in">ls</span>(p)].sum;<span class="comment">//查找p节点的左子树的数量</span></span><br><span class="line">    <span class="keyword">if</span>(ltt[p].val==x)<span class="comment">//节点中的值和x点相同</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> cc<span class="number">+1</span>;<span class="comment">//比p小的所有数的数量+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ltt[p].val&gt;x)<span class="comment">//节点中的值比x点大（向左子树跑）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findth</span>(<span class="built_in">ls</span>(p),x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//节点中的值比x点小（向右子树跑）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findth</span>(<span class="built_in">rs</span>(p),x)+cc+ltt[p].cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findkth</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> k)</span><span class="comment">//查找k点的排名（第k大的数字）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="type">int</span> cc=ltt[<span class="built_in">ls</span>(p)].sum;</span><br><span class="line">    <span class="keyword">if</span>(cc&gt;=k) <span class="keyword">return</span> <span class="built_in">findkth</span>(<span class="built_in">ls</span>(p),k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cc&lt;k &amp;&amp; cc+ltt[p].cnt&gt;=k) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">findkth</span>(<span class="built_in">rs</span>(p),k-cc-ltt[p].cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> ans)</span><span class="comment">//前驱</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">if</span>(ltt[p].val&gt;=x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pre</span>(<span class="built_in">ls</span>(p),x,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pre</span>(<span class="built_in">rs</span>(p),x,<span class="built_in">max</span>(ans,ltt[p].val));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">nxt</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> x,<span class="type">int</span> ans)</span><span class="comment">//后继</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">if</span>(ltt[p].val&lt;=x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">nxt</span>(<span class="built_in">rs</span>(p),x,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">nxt</span>(<span class="built_in">ls</span>(p),x,<span class="built_in">min</span>(ans,ltt[p].val));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//插入无限小和无限大</span></span><br><span class="line">    <span class="built_in">insert</span>(root,<span class="number">-0x7fffffff</span>);</span><br><span class="line">    <span class="built_in">insert</span>(root,<span class="number">0x7fffffff</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">findth</span>(root,b)<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;ltt[<span class="built_in">findkth</span>(root,b<span class="number">+1</span>)].val&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ans=<span class="built_in">pre</span>(root,b,<span class="number">-0x7fffffff</span>);</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ans=<span class="built_in">nxt</span>(root,b,<span class="number">0x7fffffff</span>);</span><br><span class="line">            cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">insert</span>(root,b);<span class="comment">//从根节点开始插入b</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，本题较为复杂。但是要是仔细看看的话，其实难度也不大，就是要码的字实在是太多了QAQ</p>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E9%A2%98%E8%A7%A3/">题解</category>
      
      
      <comments>https://yuzh.tech/posts/P5076/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>P5318 【深基18.例3】查找文献</title>
      <link>https://yuzh.tech/posts/P5318/</link>
      <guid>https://yuzh.tech/posts/P5318/</guid>
      <pubDate>Sat, 06 Jun 2020 15:45:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/06/06/kdHaLBXghPuobDw.png&quot; alt=&quot;题目&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/06/06/g9ICd5N4Yu1xrRz.png&quot; alt=&quot;数据&quot;&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="https://i.loli.net/2020/06/06/kdHaLBXghPuobDw.png" alt="题目"></p><p><img src="https://i.loli.net/2020/06/06/g9ICd5N4Yu1xrRz.png" alt="数据"></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>重点有两点：</p><ol><li>使用vector建立无权有向图，并使用迭代器对图排序</li><li>深搜，访问节点，使用vis进行遍历序</li></ol><p>示例代码见下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">310000</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; M[maxn];<span class="comment">//建立图（不带边权）</span></span><br><span class="line"><span class="type">bool</span> vis[maxn];<span class="comment">//每个顶点是否被访问过（dfs的遍历序，规定每个顶点只能访问一次）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//深搜，访问一个节点x</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//把节点x输出</span></span><br><span class="line">    vis[x]=<span class="number">1</span>;<span class="comment">//设置节点x已经被访问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M[x].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=M[x][i];<span class="comment">//节点x可以访问到的第i个节点</span></span><br><span class="line">        <span class="keyword">if</span>(!vis[t])<span class="comment">//节点没有被访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//广搜</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;<span class="comment">//队列中记录访问到哪个节点</span></span><br><span class="line">    vis[x]=<span class="number">1</span>;<span class="comment">//记录节点已被访问</span></span><br><span class="line">    Q.<span class="built_in">push</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> hd=Q.<span class="built_in">front</span>();<span class="comment">//调用队列头</span></span><br><span class="line">        cout&lt;&lt;hd&lt;&lt;<span class="string">&quot; &quot;</span>;<span class="comment">//队列头出队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M[hd].<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t=M[hd][i];</span><br><span class="line">            <span class="keyword">if</span>(!vis[t])<span class="comment">//节点没有被访问</span></span><br><span class="line">            &#123;</span><br><span class="line">                Q.<span class="built_in">push</span>(t);<span class="comment">//压入节点</span></span><br><span class="line">                vis[t]=<span class="number">1</span>;<span class="comment">//记录节点已被访问</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Q.<span class="built_in">pop</span>();<span class="comment">//弹出队列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        M[a].<span class="built_in">push_back</span>(b);<span class="comment">//M[a]多了一个元素b</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(M[i].<span class="built_in">begin</span>(),M[i].<span class="built_in">end</span>());<span class="comment">//对每一个顶点可到的点进行大小排序</span></span><br><span class="line">        <span class="comment">//        起始地址      结束地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);<span class="comment">//dfs</span></span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[i]=<span class="number">0</span>;<span class="comment">//清空vis数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>(<span class="number">1</span>);<span class="comment">//bfs</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E9%A2%98%E8%A7%A3/">题解</category>
      
      
      <comments>https://yuzh.tech/posts/P5318/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>P3916 图的遍历</title>
      <link>https://yuzh.tech/posts/P3916/</link>
      <guid>https://yuzh.tech/posts/P3916/</guid>
      <pubDate>Wed, 03 Jun 2020 15:30:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;题目见下，来自洛谷&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/06/04/Rvqa5AQrxnEl3pb.png&quot; alt=&quot;题目&quot;&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>题目见下，来自洛谷</p><p><img src="https://i.loli.net/2020/06/04/Rvqa5AQrxnEl3pb.png" alt="题目"></p><span id="more"></span><p>思路比较简单</p><ol><li>反向建边</li><li>dfs寻找答案</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,m;<span class="comment">//N个点，MM条边的有向图</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; M[maxn];<span class="comment">//建立一张图</span></span><br><span class="line"><span class="type">int</span> f[maxn],vis[maxn],cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[x]=id;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M[x].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=M[x][i];</span><br><span class="line">        <span class="keyword">if</span>(!vis[t])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(t,id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        M[b].<span class="built_in">push_back</span>(a);<span class="comment">//建边</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span> &amp;&amp; cnt&lt;n;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;vis[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E9%A2%98%E8%A7%A3/">题解</category>
      
      
      <comments>https://yuzh.tech/posts/P3916/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>P1113 杂物</title>
      <link>https://yuzh.tech/posts/P1113/</link>
      <guid>https://yuzh.tech/posts/P1113/</guid>
      <pubDate>Sun, 31 May 2020 15:32:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;John的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务11。John有需要完成的nn个杂务的清单，并且这份清单是有一定顺序的，杂务k(k&amp;gt;1)k(k&amp;gt;1)的准备工作只可能在杂务11至k-1k−1中。&lt;/p&gt;
&lt;p&gt;写一个程序从11到nn读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定John的农场有足够多的工人来同时完成任意多项任务。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>John的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务11。John有需要完成的nn个杂务的清单，并且这份清单是有一定顺序的，杂务k(k&gt;1)k(k&gt;1)的准备工作只可能在杂务11至k-1k−1中。</p><p>写一个程序从11到nn读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定John的农场有足够多的工人来同时完成任意多项任务。</p><span id="more"></span><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第1行：一个整数nn，必须完成的杂务的数目(3 \le n \le 10,0003≤n≤10,000)；</p><p>第22至(n+1)(n+1)行： 共有nn行，每行有一些用11个空格隔开的整数，分别表示：</p><ul><li><p>工作序号(11至nn,在输入文件中是有序的)；</p></li><li><p>完成工作所需要的时间len(1 \le len \le 100)len(1≤len≤100)；</p></li><li><p>一些必须完成的准备工作，总数不超过100100个，由一个数字00结束。有些杂务没有需要准备的工作只描述一个单独的00，整个输入文件中不会出现多余的空格。</p></li></ul><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>一个整数，表示完成所有杂务所需的最短时间。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">1 5 0</span><br><span class="line">2 2 1 0</span><br><span class="line">3 3 2 0</span><br><span class="line">4 6 1 0</span><br><span class="line">5 1 2 4 0</span><br><span class="line">6 8 2 4 0</span><br><span class="line">7 4 3 5 6 0</span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23</span><br></pre></td></tr></table></figure><p>一道拓扑排序（dfs实现）</p><p>代码见下，含有注释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span><span class="number">+5</span>;<span class="comment">//数组最大值</span></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//n表示必须完成的杂务的数目</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; M[maxn];<span class="comment">//建立的图</span></span><br><span class="line"><span class="type">int</span> ru[maxn],tim[maxn],dp[maxn],ans=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//  ru为入度 tim为时间  dp为递推结果 最终答案为ans</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;<span class="comment">//建立队列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//扫描队列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!ru[i])<span class="comment">//入度为零，放入队列</span></span><br><span class="line">        &#123;</span><br><span class="line">            Q.<span class="built_in">push</span>(i);</span><br><span class="line">            dp[i]=tim[i];<span class="comment">//记i点的递推值为i点的时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())<span class="comment">//当队列不为空时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> hd=Q.<span class="built_in">front</span>();<span class="comment">//取出队列头</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M[hd].<span class="built_in">size</span>();i++)<span class="comment">//扩展队列头</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t=M[hd][i];<span class="comment">//t为下一个点</span></span><br><span class="line">            dp[t]=<span class="built_in">max</span>(dp[t],dp[hd]+tim[t]);</span><br><span class="line">            ru[t]--;<span class="comment">//把t的入度缩小</span></span><br><span class="line">            <span class="keyword">if</span>(ru[t]==<span class="number">0</span>)<span class="comment">//入度为零</span></span><br><span class="line">            &#123;</span><br><span class="line">                Q.<span class="built_in">push</span>(t);<span class="comment">//入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Q.<span class="built_in">pop</span>();<span class="comment">//把上面的队列弹出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b,c;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        tim[a]=b;<span class="comment">//a任务完成的时间为b</span></span><br><span class="line">        cin&gt;&gt;c;<span class="comment">//前置任务</span></span><br><span class="line">        <span class="keyword">while</span>(c)</span><br><span class="line">        &#123;</span><br><span class="line">            M[c].<span class="built_in">push_back</span>(a);<span class="comment">//把c和a之间建立一条边</span></span><br><span class="line">            ru[a]++;<span class="comment">//入度增加</span></span><br><span class="line">            cin&gt;&gt;c;<span class="comment">//不断输入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();<span class="comment">//进入递归</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,dp[i]);<span class="comment">//求出dp的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E9%A2%98%E8%A7%A3/">题解</category>
      
      
      <comments>https://yuzh.tech/posts/P1113/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>拓扑排序</title>
      <link>https://yuzh.tech/posts/topological-sort/</link>
      <guid>https://yuzh.tech/posts/topological-sort/</guid>
      <pubDate>Sun, 31 May 2020 15:24:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;简单科普拓扑排序&quot;&gt;&lt;a href=&quot;#简单科普拓扑排序&quot; class=&quot;headerlink&quot; title=&quot;简单科普拓扑排序&quot;&gt;&lt;/a&gt;简单科普拓扑排序&lt;/h1&gt;&lt;p&gt;来源：&lt;a href=&quot;https://baike.baidu.com/item/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/5223807?fr=aladdin&quot;&gt;百度百科&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边&amp;lt;u,v&amp;gt;∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="简单科普拓扑排序"><a href="#简单科普拓扑排序" class="headerlink" title="简单科普拓扑排序"></a>简单科普拓扑排序</h1><p>来源：<a href="https://baike.baidu.com/item/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/5223807?fr=aladdin">百度百科</a></p><p>对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边&lt;u,v&gt;∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。</p><span id="more"></span><h1 id="手写笔记"><a href="#手写笔记" class="headerlink" title="手写笔记"></a>手写笔记</h1><p>举个栗子：</p><p>已知有课程1、2、3、4、5、6，且课程1、2完成后才可以完成课程3，课程三完成后才可以完成课程4、5，课程4、5完成后才可以完成课程6。</p><p>于是可得下面这幅拓扑排序图</p><p><img src="https://i.loli.net/2020/05/31/5JF2W36UHfOGZvD.png" alt="图一"></p><p><img src="https://i.loli.net/2020/05/31/Sa61mkWEND4X7KG.png" alt="图二"></p>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E7%A7%91%E6%99%AE/">科普</category>
      
      
      <comments>https://yuzh.tech/posts/topological-sort/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>P2390</title>
      <link>https://yuzh.tech/posts/P2390/</link>
      <guid>https://yuzh.tech/posts/P2390/</guid>
      <pubDate>Tue, 26 May 2020 15:30:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;题面&quot;&gt;&lt;a href=&quot;#题面&quot; class=&quot;headerlink&quot; title=&quot;题面&quot;&gt;&lt;/a&gt;题面&lt;/h1&gt;&lt;h2 id=&quot;题目背景&quot;&gt;&lt;a href=&quot;#题目背景&quot; class=&quot;headerlink&quot; title=&quot;题目背景&quot;&gt;&lt;/a&gt;题目背景&lt;/h2&gt;&lt;p&gt;改编自USACO2007Nov铜组Exploration&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;贝西在一条道路上旅行，道路上有许多地标，贝西想要在日落之前访问尽可能多的路标。将道路视为一条数轴，贝西从原点出发，道路上有n(1&amp;lt;&amp;#x3D;n&amp;lt;&amp;#x3D;50000)个地标，每个地标有一个坐标x[i](-100,000 ≤ xi ≤ 100,000)且地标的坐标各不相同，t(1≤ T ≤1000000000)分钟之后将会日落。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>改编自USACO2007Nov铜组Exploration</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>贝西在一条道路上旅行，道路上有许多地标，贝西想要在日落之前访问尽可能多的路标。将道路视为一条数轴，贝西从原点出发，道路上有n(1&lt;&#x3D;n&lt;&#x3D;50000)个地标，每个地标有一个坐标x[i](-100,000 ≤ xi ≤ 100,000)且地标的坐标各不相同，t(1≤ T ≤1000000000)分钟之后将会日落。</p><span id="more"></span><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行：两个整数t,n</p><p>第二行至第n+1行：地标的坐标x[i]</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，贝西能访问的最多的地标数</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><figure class="highlight plaintext"><figcaption><span>#1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">25 14</span><br><span class="line">16</span><br><span class="line">8</span><br><span class="line">-7</span><br><span class="line">3</span><br><span class="line">10</span><br><span class="line">-15</span><br><span class="line">-17</span><br><span class="line">6</span><br><span class="line">-12</span><br><span class="line">14</span><br><span class="line">-13</span><br><span class="line">2</span><br><span class="line">9</span><br><span class="line">-5</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>#1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明&#x2F;提示"></a>说明&#x2F;提示</h2><p>贝西日落时不用回到原点。</p><hr><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>代码部分参考@<a href="https://www.luogu.com.cn/user/130199">NiveusNix</a>的题解</p><p>由题意，想要最快捷地走更多的路，就不能有重复的路，因此分下面四种情况</p><ol><li><p>从原点一直往右走</p></li><li><p>从原点一直往左走</p></li><li><p>从原点往左走一段再往右走</p></li><li><p>从原点往右走一段再往左走</p></li></ol><p>首先，对输入数据进行排序。</p><p>其次，分类讨论：</p><p>第一种和第二种情况可以直接模拟过去</p><p>第三种和第四种则稍微麻烦一点点，需要使用二分来缩减范围。</p><ol><li><p>设定二分中点</p></li><li><p>算出当前所需要的时间（左边所需要的时间*2 + 右边所需要的时间（另外一种情况结论相反））</p></li><li><p>判断范围，继续二分 or 结束二分得出结果</p></li></ol><p>代码如下，含有注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> t,n,s,L[<span class="number">50010</span>],R[<span class="number">50010</span>];<span class="comment">//L[]存在原点左边的地标离原点的距离，R[]存在原点右边的地标离原点的距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;t&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> ll=<span class="number">0</span>,lr=<span class="number">0</span>,sum=<span class="number">0</span>;<span class="comment">//ll是左边最远地标离原点的距离，lr是右边最远地标离原点的距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//分类（原点左右）</span></span><br><span class="line">&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">        sum=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">lr++;</span><br><span class="line">            R[lr]=s;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ll++;</span><br><span class="line">            L[ll]=-s;           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(L<span class="number">+1</span>,L+ll<span class="number">+1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(R<span class="number">+1</span>,R+lr<span class="number">+1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> t3=<span class="number">0</span>,t4=<span class="number">0</span>,mt1=<span class="number">0</span>,mt2=<span class="number">0</span>,mt3=<span class="number">0</span>,mt4=<span class="number">0</span>;<span class="comment">//t3是第3种情况的子任务解，t4是第4种情况的子任务解，mt1-4是每种情况的最优解</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=ll;i++)&#123;<span class="comment">//直接往右走</span></span><br><span class="line">        <span class="keyword">if</span>(L[i]&lt;=t)&#123;</span><br><span class="line">            mt1+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lr;i++)&#123;<span class="comment">//直接往左走</span></span><br><span class="line">        <span class="keyword">if</span>(R[i]&lt;=t)&#123;</span><br><span class="line">            mt2+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> le,ri,mid;<span class="comment">//临时左右分段，和二分中点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=ll;i++)&#123;<span class="comment">//先枚举左边，回头向右走的坐标</span></span><br><span class="line">        le=<span class="number">1</span>;</span><br><span class="line">        ri=lr;</span><br><span class="line">        <span class="keyword">while</span>(ri&gt;=le)&#123;<span class="comment">//二分查找向右到达的坐标</span></span><br><span class="line">            mid=(ri+le)/<span class="number">2</span>;</span><br><span class="line">            t3=L[i]*<span class="number">2</span>+R[mid];<span class="comment">//算出当前所需要的时间</span></span><br><span class="line">    <span class="keyword">if</span>(t3&gt;t)&#123;</span><br><span class="line">                ri=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                le=mid<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mt3=<span class="built_in">max</span>(mt3,i+ri);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lr;i++)&#123;<span class="comment">//先枚举右边，回头向左走的坐标</span></span><br><span class="line">        le=<span class="number">1</span>;</span><br><span class="line">        ri=ll;</span><br><span class="line">        <span class="keyword">while</span>(ri&gt;=le)&#123;<span class="comment">//二分查找向左到达的坐标</span></span><br><span class="line">            mid=(ri+le)/<span class="number">2</span>;</span><br><span class="line">            t4=R[i]*<span class="number">2</span>+L[mid];<span class="comment">//算出当前所需要的时间</span></span><br><span class="line">            <span class="keyword">if</span>(t4&gt;t)&#123;</span><br><span class="line">                ri=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                le=mid<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mt4=<span class="built_in">max</span>(mt4,i+ri);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">max</span>(<span class="built_in">max</span>(mt1,mt2),<span class="built_in">max</span>(mt3,mt4));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E9%A2%98%E8%A7%A3/">题解</category>
      
      
      <comments>https://yuzh.tech/posts/P2390/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>教你用树莓派来搭建一个NAS数据中心</title>
      <link>https://yuzh.tech/posts/rpi_nextcloud_deploy/</link>
      <guid>https://yuzh.tech/posts/rpi_nextcloud_deploy/</guid>
      <pubDate>Sun, 10 May 2020 13:00:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;教你用树莓派来搭建一个NAS数据中心&quot;&gt;&lt;a href=&quot;#教你用树莓派来搭建一个NAS数据中心&quot; class=&quot;headerlink&quot; title=&quot;教你用树莓派来搭建一个NAS数据中心&quot;&gt;&lt;/a&gt;教你用树莓派来搭建一个NAS数据中心&lt;/h1&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="教你用树莓派来搭建一个NAS数据中心"><a href="#教你用树莓派来搭建一个NAS数据中心" class="headerlink" title="教你用树莓派来搭建一个NAS数据中心"></a>教你用树莓派来搭建一个NAS数据中心</h1><span id="more"></span><div class="note info">            <p>本文的NAS系统用的是Ubuntu 18.04 LTS + Nextcloud最新版本</p>          </div><h2 id="安装前配置"><a href="#安装前配置" class="headerlink" title="安装前配置"></a>安装前配置</h2><h3 id="安装宝塔"><a href="#安装宝塔" class="headerlink" title="安装宝塔"></a>安装宝塔</h3><p>宝塔的安装此处不在赘述，<a href="bt.cn">教程在此</a></p><h3 id="安装php-7-2及以上版本，推荐7-3或7-4"><a href="#安装php-7-2及以上版本，推荐7-3或7-4" class="headerlink" title="安装php 7.2及以上版本，推荐7.3或7.4"></a>安装php 7.2及以上版本，推荐7.3或7.4</h3><p>php可在宝塔中安装，非常简单</p><h3 id="安装Nginx或者Apache"><a href="#安装Nginx或者Apache" class="headerlink" title="安装Nginx或者Apache"></a>安装Nginx或者Apache</h3><p>同样可在宝塔软件中心中安装，但是Apache和Nginx只能安装一个，不可同时安装。配置差的机器推荐使用Nginx。</p><h3 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h3><p>版本根据机器配置自行选择，同理不再赘述。</p><h2 id="下载并安装Nextcloud"><a href="#下载并安装Nextcloud" class="headerlink" title="下载并安装Nextcloud"></a>下载并安装Nextcloud</h2><h3 id="下载Nextcloud"><a href="#下载Nextcloud" class="headerlink" title="下载Nextcloud"></a>下载Nextcloud</h3><p>前往<a href="https://hexoian.cn/resources/16/">Hexoian论坛</a>，下载Nextcloud源码包。</p><p>ps:速度会比官网下快不少哦</p><h3 id="安装Nextcloud"><a href="#安装Nextcloud" class="headerlink" title="安装Nextcloud"></a>安装Nextcloud</h3><p>在宝塔的网站管理中新建网站，数据库也可不新建，但如果新建了，要记住账户密码。</p><p><img src="https://i.loli.net/2020/05/07/uqoQ2p51bP7gIMx.png" alt="1.png"></p><p>进入网站根目录，把下载的文件解压进去，像这样</p><p><img src="https://i.loli.net/2020/05/07/VlA2fCHTJjnKyoQ.png" alt="2.png"></p><p>打开你所设置的ip以及端口，然后会看到这个东西</p><p><img src="https://i.loli.net/2020/05/07/AnxljVFWT1ocCIE.png" alt="3.png"></p><p>设置好你自己的用户名和密码，不用安装哪些捆绑应用。NC默认使用SQLite如果想用Mysql数据库来存放的话，下面数据库那里展开，填写你数据库的信息。</p><p>等待一会儿，然后可能会出错，重载下数据库配置，再重启下数据库，然后重启php，重启Apache或者Nginx，可能还会炸，重新注册个账号就能进了（名字要和之前不一样）</p><p>一切就绪，会直接进入Nextcloud。</p><p><img src="https://i.loli.net/2020/05/07/hSP2FsmpwM4BDIl.png" alt="4.png"></p><p><img src="https://i.loli.net/2020/05/07/9uHyI76CVGkZPc4.png" alt="5.png"></p><h2 id="安装完成！"><a href="#安装完成！" class="headerlink" title="安装完成！"></a>安装完成！</h2>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/">树莓派</category>
      
      
      <comments>https://yuzh.tech/posts/rpi_nextcloud_deploy/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>教你搭建一个专业的论坛系统---Xenforo</title>
      <link>https://yuzh.tech/posts/xenforo_deploy/</link>
      <guid>https://yuzh.tech/posts/xenforo_deploy/</guid>
      <pubDate>Wed, 01 Apr 2020 08:00:00 GMT</pubDate>
      
      <description>教你搭建一个专业的论坛系统---Xenforo</description>
      
      
      
      <content:encoded><![CDATA[<div class="note warning">            <p>本文资源包<a href="https://www.lanzous.com/iastpmj">点此下载</a>，密码为<strong>yuzh</strong></p>          </div><h1 id="教你搭建一个专业的论坛系统—Xenforo"><a href="#教你搭建一个专业的论坛系统—Xenforo" class="headerlink" title="教你搭建一个专业的论坛系统—Xenforo"></a>教你搭建一个专业的论坛系统—Xenforo</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="安装宝塔Linux面板"><a href="#安装宝塔Linux面板" class="headerlink" title="安装宝塔Linux面板"></a>安装宝塔Linux面板</h3><p>进入<a href="https://bt.cn/">宝塔官网</a>，参考官网文档下载安装。</p><div class="note warning">            <p>根据需要选择运行库！</p><span id="more"></span><p>MySql至少需为5.7，php至少需为7.3！！</p><p>如下图所示</p><p><img src="https://i.loli.net/2020/04/02/5UgycltGjp8dx7J.png" alt="运行库"></p>          </div><p><img src="/posts/xenforo_deploy/" alt="安装环境"></p><div class="note success">            <p>经过漫长的等待，等待安装完成</p>          </div><hr><h2 id="下载论坛资源包"><a href="#下载论坛资源包" class="headerlink" title="下载论坛资源包"></a>下载论坛资源包</h2><p>接下来，下载我打包的Xenforo包（有钱人请<a href="https://xenforo.com/">支持正版！！</a>），并放到你服务器上。</p><hr><h2 id="在宝塔内添加动态网站"><a href="#在宝塔内添加动态网站" class="headerlink" title="在宝塔内添加动态网站"></a>在宝塔内添加动态网站</h2><p>如下图所示，自行配置，要记住mysql的账号和密码（不记住也可，可以自己去找）</p><p><img src="https://i.loli.net/2020/04/02/HvfBCKjxsMOmklV.png" alt="新建网站"></p><div class="note warning">            <p>端口一定要记住！！</p>          </div><hr><h2 id="导入网站资源包"><a href="#导入网站资源包" class="headerlink" title="导入网站资源包"></a>导入网站资源包</h2><p>将xenforo_2.1.8_Patch_1文件夹中的upload文件夹中的内容上传至网站的根目录（其实剪切过去更快），然后把upload文件夹中的内容剪切到根目录，结果如下图所示</p><p><img src="https://i.loli.net/2020/04/02/hzOu291DJTIjcHw.png" alt="install"></p><p>然后打开网站&lt;服务器IP&gt;:&lt;你之前设置的端口&gt;</p><p>打开后可能会有下面的提示，可以在宝塔中更改php的配置—禁用函数</p><p><img src="https://i.loli.net/2020/04/02/pm2l4TPy67DBbtM.png" alt="warning"></p><p>找到exec，proc_open，popen这三项，删掉，重启php服务。</p><p><img src="https://i.loli.net/2020/04/02/DI8whbylKMUjqin.png" alt="delete"></p><p>重新进入网站，成功！</p><p><img src="https://i.loli.net/2020/04/02/zJEtg2hAK8sFrc1.png" alt="success!!"></p><p>点击next，输入mysql的账户和密码</p><p><img src="https://i.loli.net/2020/04/02/i8fsg32MNT6nBoL.png" alt="账号密码"></p><p>点击Save config，然后Contiune，Begin Installation</p><p><img src="https://i.loli.net/2020/04/02/CPbo8nOlDKYVj1m.png" alt="processing..."></p><p>等待1-5分钟，输入管理员用户信息（自己设置），下一步Send anonymous server statistics 不用选，没有用。</p><p>最后，提示进入管理系统，自行登录。</p><div class="note success">            <p>Xenforo安装成功</p>          </div><hr><h2 id="为Xenforo配置中文语言包"><a href="#为Xenforo配置中文语言包" class="headerlink" title="为Xenforo配置中文语言包"></a>为Xenforo配置中文语言包</h2><p>首先，进入论坛管理系统。</p><p>进入Appearance-Languages</p><p><img src="https://i.loli.net/2020/04/02/Vi5lhdprxtzuj2e.png" alt="language"></p><p>点击“浏览”，上传资源包中的XenforoChinesePACK.xml，然后单击“Import”。结束后，选择“简体中文”。</p><p><img src="https://i.loli.net/2020/04/02/3mrionYKcxjTJNC.png" alt="import"></p><div class="note success">            <p>中文语言包安装成功</p>          </div><hr><p>然后，进入设置-选项-用户注册选项-为游客开启CAPTCHA，选择“使用问题 &amp; 回答 CAPTCHA”，然后单击“使用明确的问题”</p><p><img src="https://i.loli.net/2020/04/02/p7lJDdTUSyFNnfQ.png" alt="CAPTCHA"></p><p>设置好你自己的问题和答案，如下图所示。</p><p><img src="https://i.loli.net/2020/04/02/Q9xHYyRk5BM8I7s.png" alt="Q&amp;A"></p><p>最后，进入设置-选项-邮件系统选项，设置好你自己的邮件，然后进入工具-邮件发出测试，测试你设置的邮箱是否可用。</p><div class="note success">            <p>配置成功！！</p>          </div>]]></content:encoded>
      
      
      
      
      <comments>https://yuzh.tech/posts/xenforo_deploy/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>一句命令教你找到Linux中的特大文件</title>
      <link>https://yuzh.tech/posts/linux_delete_large_file/</link>
      <guid>https://yuzh.tech/posts/linux_delete_large_file/</guid>
      <pubDate>Wed, 25 Mar 2020 11:00:00 GMT</pubDate>
      
      <description>一句命令教你如何找到Linux中的特大文件</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="一句命令教你找到Linux中的特大文件"><a href="#一句命令教你找到Linux中的特大文件" class="headerlink" title="一句命令教你找到Linux中的特大文件"></a>一句命令教你找到Linux中的特大文件</h1><blockquote><p>写这篇文章的原因是我在自己的服务器上发现空间爆满，最后好不容易才找到了一个奇葩的log文件，见图。<br><img src="https://i.loli.net/2020/03/25/aoBd1NTPAw86Lsb.png" alt="OHHHH！"><br><img src="https://i.loli.net/2020/03/25/zZHAlcvbh13GpB9.png" alt="log"></p></blockquote><span id="more"></span><h2 id="搜索特大文件位置"><a href="#搜索特大文件位置" class="headerlink" title="搜索特大文件位置"></a>搜索特大文件位置</h2><p>首先，cd至根目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">cd /</span><br></pre></td></tr></table></figure><p>然后进行搜索。注意，这里使用的是”du -h”命令，来查找当前目录的文件夹及文件的大小。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始搜索</span></span><br><span class="line">du -sh *</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/03/25/V9bWFfHhK6zyck8.png" alt="search"></p><p>然后进入这个文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd var</span><br></pre></td></tr></table></figure><p>同样，继续搜索文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh *</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/03/25/5W8viVunMbA9xwz.png" alt="search"></p><p>发现了log这个文件夹很可疑，进去看看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd log</span><br></pre></td></tr></table></figure><p>搜索文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh *</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/03/25/g3sM6pXGbSPIvjl.png" alt="search"></p><p>发现是apt这个文件夹的锅，进去继续搜索</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd apt</span><br><span class="line">du -sh *</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/03/25/5tbfakBOwluVicn.png" alt="final search"></p><p>居然是这样一个奇葩的log文件？？？</p><p>rm -rf 试试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf term1.log</span><br></pre></td></tr></table></figure><p>看看硬盘占用~~</p><p><img src="https://i.loli.net/2020/03/25/gmeX1yhfnVWD3aR.png" alt="AWESOME"></p><p>Awesome~~  一下子掉了4G^_^</p><hr><p>文章结束了，求个回复或者收藏本站呗~~</p>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E5%B9%B2%E8%B4%A7/">干货</category>
      
      
      <comments>https://yuzh.tech/posts/linux_delete_large_file/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>如何为你的树莓派安装一个好看的主题---Butterfly</title>
      <link>https://yuzh.tech/posts/hexo_theme_butterfly/</link>
      <guid>https://yuzh.tech/posts/hexo_theme_butterfly/</guid>
      <pubDate>Thu, 12 Mar 2020 00:00:00 GMT</pubDate>
      
      <description>如何为你的树莓派安装一个好看的主题---Butterfly</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="如何为你的树莓派安装一个好看的主题—Butterfly"><a href="#如何为你的树莓派安装一个好看的主题—Butterfly" class="headerlink" title="如何为你的树莓派安装一个好看的主题—Butterfly"></a>如何为你的树莓派安装一个好看的主题—Butterfly</h1><blockquote><p>本文是前文<a href="/2020/02/20/hexo-first-deploy/">从零开始 Hexo博客搭建</a>的后续。</p></blockquote><p>文章有参考主题<a href="https://jerryc.me/posts/21cfbf15/">作者的博客</a></p><span id="more"></span><h2 id="安装环境（一定要装！！！）"><a href="#安装环境（一定要装！！！）" class="headerlink" title="安装环境（一定要装！！！）"></a>安装环境（一定要装！！！）</h2><p>首先，cd至博客根目录</p><blockquote><p>注意，需要首先安装好Node.js和Git！</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd blog # 此处的blog更改为你所设置的名称</span><br></pre></td></tr></table></figure><p>然后，安装cheerio和渲染器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install cheerio –save</span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p>可以选择标准版，git clone下来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br></pre></td></tr></table></figure><p>也可以选择dev版</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br></pre></td></tr></table></figure><p>最后，更改博客根目录_config.yml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: Butterfly</span><br></pre></td></tr></table></figure><p>当然，也可以自行选择平滑升级（我自己没用），执行下面代码后可以通过git pull升级，但是之后配置文件就需要改butterfly.yml了，看个人喜好自愿执行下面步骤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp source/themes/Butterfly/_config.yml source/_data/butterfly.yml</span><br></pre></td></tr></table></figure><p>恭喜，安装完成！</p><hr><h2 id="进行页面设置"><a href="#进行页面设置" class="headerlink" title="进行页面设置"></a>进行页面设置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags # 标签页</span><br><span class="line">hexo new page categories # 分类页</span><br><span class="line">hexo new page link # 友链页</span><br></pre></td></tr></table></figure><p>然后编辑界面文件</p><p>标签页：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano source/tags/index.md</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2020-03-01 00:00:00</span><br><span class="line">type: &quot;tags&quot;</span><br></pre></td></tr></table></figure><p>分类页：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano source/categories/index.md</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2018-01-05 00:00:00</span><br><span class="line">type: &quot;categories&quot;</span><br></pre></td></tr></table></figure><p>友链页：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano source/link/index.md</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: 友情链接</span><br><span class="line">date: 2018-06-07 22:17:49</span><br><span class="line">type: &quot;link&quot;</span><br></pre></td></tr></table></figure><p>配置友链</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano source/_data/link.yml</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class:</span><br><span class="line">  class_name: 友情链接</span><br><span class="line">  link_list:</span><br><span class="line">    1:</span><br><span class="line">      name: xxx #名称</span><br><span class="line">      link: https://blog.xxx.com # 链接</span><br><span class="line">      avatar: https://xxxxx/avatar.png # 头像</span><br><span class="line">      descr: xxxxxxx # 描述</span><br><span class="line">    2: # 内容同下</span><br><span class="line">      name: xxxxxx</span><br><span class="line">      link: https://www.xxxxxxcn/</span><br><span class="line">      avatar: https://xxxxx/avatar.png</span><br><span class="line">      descr: xxxxxxx</span><br></pre></td></tr></table></figure><hr><p>到这里差不多就完成基本配置了，更多配置信息可以前往<a href="https://jerryc.me/posts/21cfbf15/">作者的博客</a>或者<a href="https://github.com/Molunerfinn/hexo-theme-melody">hexo-theme-melody</a>获取。</p><h2 id="最后，点赞、收藏！！"><a href="#最后，点赞、收藏！！" class="headerlink" title="最后，点赞、收藏！！"></a>最后，点赞、收藏！！</h2>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E5%B9%B2%E8%B4%A7/">干货</category>
      
      
      <comments>https://yuzh.tech/posts/hexo_theme_butterfly/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>如何用树莓派搭建可视化的aria2挂机下载器</title>
      <link>https://yuzh.tech/posts/raspi_aria2_install/</link>
      <guid>https://yuzh.tech/posts/raspi_aria2_install/</guid>
      <pubDate>Sat, 29 Feb 2020 14:00:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;如何用树莓派搭建可视化的aria2挂机下载器&quot;&gt;&lt;a href=&quot;#如何用树莓派搭建可视化的aria2挂机下载器&quot; class=&quot;headerlink&quot; title=&quot;如何用树莓派搭建可视化的aria2挂机下载器&quot;&gt;&lt;/a&gt;如何用树莓派搭建可视化的aria2挂机下载器&lt;/h1&gt;&lt;h2 id=&quot;安装环境&quot;&gt;&lt;a href=&quot;#安装环境&quot; class=&quot;headerlink&quot; title=&quot;安装环境&quot;&gt;&lt;/a&gt;安装环境&lt;/h2&gt;&lt;h3 id=&quot;nodejs&quot;&gt;&lt;a href=&quot;#nodejs&quot; class=&quot;headerlink&quot; title=&quot;nodejs&quot;&gt;&lt;/a&gt;nodejs&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;/2020/02/19/hexo-first-deploy/#%E5%AE%89%E8%A3%85nodejs/&quot;&gt;前文&lt;/a&gt;已经提到，不再赘述&lt;/p&gt;
&lt;h3 id=&quot;nginx&quot;&gt;&lt;a href=&quot;#nginx&quot; class=&quot;headerlink&quot; title=&quot;nginx&quot;&gt;&lt;/a&gt;nginx&lt;/h3&gt;&lt;p&gt;只需安装宝塔即可，&lt;a href=&quot;/2020/02/26/raspi_bt_install/&quot;&gt;前文&lt;/a&gt;已经提到，不再赘述&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="如何用树莓派搭建可视化的aria2挂机下载器"><a href="#如何用树莓派搭建可视化的aria2挂机下载器" class="headerlink" title="如何用树莓派搭建可视化的aria2挂机下载器"></a>如何用树莓派搭建可视化的aria2挂机下载器</h1><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><h3 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h3><p><a href="/2020/02/19/hexo-first-deploy/#%E5%AE%89%E8%A3%85nodejs/">前文</a>已经提到，不再赘述</p><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><p>只需安装宝塔即可，<a href="/2020/02/26/raspi_bt_install/">前文</a>已经提到，不再赘述</p><span id="more"></span><h3 id="aria2"><a href="#aria2" class="headerlink" title="aria2"></a>aria2</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install aria2</span><br></pre></td></tr></table></figure><h2 id="配置aria2"><a href="#配置aria2" class="headerlink" title="配置aria2"></a>配置aria2</h2><p>但是光aria2还不够，需要有aria2的配置文件并让aria2开机自启。按如下配置。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>创建配置文件及文件夹，进入nano编辑器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/aria2</span><br><span class="line">touch /etc/aria2/aria2.session</span><br><span class="line">nano /etc/aria2/aria2.conf</span><br></pre></td></tr></table></figure><p>编辑配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 文件保存相关 ##</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件保存目录 此处文件保存目录自行设定</span></span><br><span class="line">dir=/srv/dev-disk-by-label-Kingston/Kingston/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M</span></span><br><span class="line">disk-cache=32M</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">断点续传</span></span><br><span class="line">continue=true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">预分配所需时间: none &lt; falloc ? trunc &lt; prealloc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">falloc和trunc则需要文件系统和内核支持</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">file-allocation=falloc</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 下载连接相关 ##</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最大同时下载任务数, 运行时可修改, 默认:5</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">max-concurrent-downloads=5</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同一服务器连接数, 添加时可指定, 默认:1</span></span><br><span class="line">max-connection-per-server=15</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">整体下载速度限制, 运行时可修改, 默认:0（不限制）</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">max-overall-download-limit=0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单个任务下载速度限制, 默认:0（不限制）</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">max-download-limit=0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">整体上传速度限制, 运行时可修改, 默认:0（不限制）</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">max-overall-upload-limit=0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单个任务上传速度限制, 默认:0（不限制）</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">max-upload-limit=0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁用IPv6, 默认:<span class="literal">false</span></span></span><br><span class="line">disable-ipv6=true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载</span></span><br><span class="line">min-split-size=10M</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单个任务最大线程数, 添加时可指定, 默认:5</span></span><br><span class="line">split=10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 进度保存相关 ##</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从会话文件中读取下载任务</span></span><br><span class="line">input-file=/etc/aria2/aria2.session</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在Aria2退出时保存错误的、未完成的下载任务到会话文件</span></span><br><span class="line">save-session=/etc/aria2/aria2.session</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0</span></span><br><span class="line">save-session-interval=60</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># RPC相关设置 ##</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用RPC, 默认:<span class="literal">false</span></span></span><br><span class="line">enable-rpc=true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许所有来源, 默认:<span class="literal">false</span></span></span><br><span class="line">rpc-allow-origin-all=true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许外部访问, 默认:<span class="literal">false</span></span></span><br><span class="line">rpc-listen-all=true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">RPC端口, 仅当默认端口被占用时修改</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rpc-listen-port=6800</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rpc-secret=&lt;TOKEN&gt;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># BT/PT下载相关 ##</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:<span class="literal">true</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">follow-torrent=<span class="literal">true</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端伪装, PT需要</span></span><br><span class="line">peer-id-prefix=-TR2770-</span><br><span class="line">user-agent=Transmission/2.77</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制保存会话, 即使任务已经完成, 默认:<span class="literal">false</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">较新的版本开启后会在任务完成后依然保留.aria2文件</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">force-save=<span class="literal">false</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">继续之前的BT任务时, 无需再次校验, 默认:<span class="literal">false</span></span></span><br><span class="line">bt-seed-unverified=true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存磁力链接元数据为种子文件(.torrent文件), 默认:<span class="literal">false</span></span></span><br><span class="line">bt-save-metadata=true</span><br></pre></td></tr></table></figure><p>Ctrl+O保存然后Ctrl+X退出，刷新配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aria2c --conf-path=/etc/aria2/aria2.conf -D</span><br></pre></td></tr></table></figure><h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><p>创建service服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/init.d/aria2c</span><br></pre></td></tr></table></figure><p>编辑service服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## BEGIN INIT INFO</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Provides:          aria2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Required-Start:    remotefsnetwork</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Required-Stop:     remotefsnetwork</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Default-Start:     2 3 4 5</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Default-Stop:      0 1 6</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Short-Description: Aria2 Downloader</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## END INIT INFO</span></span></span><br><span class="line"> </span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line">    echo -n &quot;Starting aria2c&quot;</span><br><span class="line">    sudo aria2c --conf-path=/etc/aria2/aria2.conf -D</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">    echo -n &quot;Shutting down aria2c &quot;</span><br><span class="line">    killall aria2c</span><br><span class="line">;;</span><br><span class="line">restart)</span><br><span class="line">    # killall aria2c</span><br><span class="line">    sudo aria2c --conf-path=/etc/aria2/aria2.conf -D</span><br><span class="line"></span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>让服务变为可执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/init.d/aria2c</span><br></pre></td></tr></table></figure><p>完成！</p><hr><h2 id="搭建可视化界面webui-aria2"><a href="#搭建可视化界面webui-aria2" class="headerlink" title="搭建可视化界面webui-aria2"></a>搭建可视化界面webui-aria2</h2><p>首先，git clone下来webui-aria2并进入文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ziahamza/webui-aria2.git</span><br><span class="line">cd webui-aria2-master</span><br></pre></td></tr></table></figure><p>然后，编辑配置文件，设置端口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano node-server.js</span><br></pre></td></tr></table></figure><p>下图所圈画的即为本地端口号，可自行修改。</p><p><img src="https://i.loli.net/2020/02/29/RQpPmWvg3qiYBxz.png" alt="aria2-webui-port"></p><p>修改完后，Ctrl+O保存然后Ctrl+X退出，运行node-server。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node node-server.js</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/29/MiOBPrhNvfy7RQs.png" alt="aria2-webui-server"></p><p>接下来，进入浏览器，输入&lt;服务器的IP地址&gt;:&lt;你设置的端口号&gt;，可看到如下所示的界面，恭喜，安装成功！</p><p><img src="https://i.loli.net/2020/02/29/PQYnbUktdsVLB9e.png" alt="aria2-webui-ui"></p>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E5%B9%B2%E8%B4%A7/">干货</category>
      
      
      <comments>https://yuzh.tech/posts/raspi_aria2_install/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>如何为你的Linux装上宝塔面板5.9(稳定版)</title>
      <link>https://yuzh.tech/posts/raspi_bt_install/</link>
      <guid>https://yuzh.tech/posts/raspi_bt_install/</guid>
      <pubDate>Wed, 26 Feb 2020 14:00:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;如何为你的Linux装上宝塔面板5-9-稳定版&quot;&gt;&lt;a href=&quot;#如何为你的Linux装上宝塔面板5-9-稳定版&quot; class=&quot;headerlink&quot; title=&quot;如何为你的Linux装上宝塔面板5.9(稳定版)&quot;&gt;&lt;/a&gt;如何为你的Linux装上宝塔面板5.9(稳定版)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;注意：已安装过非宝塔面板安装的Apache&amp;#x2F;Nginx&amp;#x2F;php&amp;#x2F;MySQL的系统不可安装！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：32位操作系统请不要看了，宝塔不支持32位操作系统&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文的安装环境是Ubuntu 18.04 LTS (armhf)，接下来的步骤都是以本安装环境为准，不同系统请自行更改。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="如何为你的Linux装上宝塔面板5-9-稳定版"><a href="#如何为你的Linux装上宝塔面板5-9-稳定版" class="headerlink" title="如何为你的Linux装上宝塔面板5.9(稳定版)"></a>如何为你的Linux装上宝塔面板5.9(稳定版)</h1><blockquote><p>注意：已安装过非宝塔面板安装的Apache&#x2F;Nginx&#x2F;php&#x2F;MySQL的系统不可安装！！</p></blockquote><blockquote><p>注意：32位操作系统请不要看了，宝塔不支持32位操作系统</p></blockquote><p>本文的安装环境是Ubuntu 18.04 LTS (armhf)，接下来的步骤都是以本安装环境为准，不同系统请自行更改。</p><span id="more"></span><h2 id="Ubuntu-18-04-LTS-安装"><a href="#Ubuntu-18-04-LTS-安装" class="headerlink" title="Ubuntu 18.04 LTS 安装"></a>Ubuntu 18.04 LTS 安装</h2><p>Ubuntu 18.04 LTS 安装（Ubuntu全系列以及Debian系统(包括Raspbian) 均可使用此方法进行安装）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O install.sh http://download.bt.cn/install/install-ubuntu.sh &amp;&amp; sudo bash install.sh</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/26/OjLWNutwGvYJmpD.png" alt="安装完成"></p><p>如上图所示即为安装完成（其他版本的安装见文底）</p><hr><p>通过浏览器进入宝塔面板（<IP>:8888）</IP></p><p>接下来，会弹出一个窗口，允许安装，总共有5个软件，包括Apache，Nginx，php5，MySQL和Pure-Ftpd。安装时间会很长，大概两三个小时。由于我这里已经安装好了，就不演示了。</p><p>主页长这样</p><p><img src="https://i.loli.net/2020/02/26/vABHTcDqRmfyKIM.png" alt="index"></p><h2 id="其它系统安装"><a href="#其它系统安装" class="headerlink" title="其它系统安装"></a>其它系统安装</h2><ul><li>CentOS</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; sh install.sh</span><br></pre></td></tr></table></figure><ul><li>Fedora</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; bash install.sh</span><br></pre></td></tr></table></figure><hr><p>恭喜，安装完成！！</p><p>最后，别忘了——</p><h2 id="评论，转载，收藏！"><a href="#评论，转载，收藏！" class="headerlink" title="评论，转载，收藏！"></a>评论，转载，收藏！</h2>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E5%B9%B2%E8%B4%A7/">干货</category>
      
      
      <comments>https://yuzh.tech/posts/raspi_bt_install/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>如何为你宝贵的树莓派定做一个温控风扇</title>
      <link>https://yuzh.tech/posts/raspi_smart_fan/</link>
      <guid>https://yuzh.tech/posts/raspi_smart_fan/</guid>
      <pubDate>Tue, 25 Feb 2020 05:00:00 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;如何为你宝贵的树莓派定做一个温控风扇&quot;&gt;&lt;a href=&quot;#如何为你宝贵的树莓派定做一个温控风扇&quot; class=&quot;headerlink&quot; title=&quot;如何为你宝贵的树莓派定做一个温控风扇&quot;&gt;&lt;/a&gt;如何为你宝贵的树莓派定做一个温控风扇&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;文章参考：&lt;a href=&quot;https://yuerblog.cc/2018/10/31/raspberry3b-pi-pnp-smart-cooling-fan/&quot;&gt;树莓派3B PNP三极管 智能温控风扇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;需要的材料&quot;&gt;&lt;a href=&quot;#需要的材料&quot; class=&quot;headerlink&quot; title=&quot;需要的材料&quot;&gt;&lt;/a&gt;需要的材料&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;杜邦线&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需要所有的三种杜邦线——公对公、公对母、母对母。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PNP三极管&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推荐TO-92型号的三极管，符合教程的需求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个1kΩ的电阻&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推荐金属膜电阻，方便耐用。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="如何为你宝贵的树莓派定做一个温控风扇"><a href="#如何为你宝贵的树莓派定做一个温控风扇" class="headerlink" title="如何为你宝贵的树莓派定做一个温控风扇"></a>如何为你宝贵的树莓派定做一个温控风扇</h1><blockquote><p>文章参考：<a href="https://yuerblog.cc/2018/10/31/raspberry3b-pi-pnp-smart-cooling-fan/">树莓派3B PNP三极管 智能温控风扇</a></p></blockquote><h2 id="需要的材料"><a href="#需要的材料" class="headerlink" title="需要的材料"></a>需要的材料</h2><blockquote><p>杜邦线</p></blockquote><p>需要所有的三种杜邦线——公对公、公对母、母对母。</p><blockquote><p>PNP三极管</p></blockquote><p>推荐TO-92型号的三极管，符合教程的需求。</p><blockquote><p>一个1kΩ的电阻</p></blockquote><p>推荐金属膜电阻，方便耐用。</p><span id="more"></span><h2 id="硬件安装"><a href="#硬件安装" class="headerlink" title="硬件安装"></a>硬件安装</h2><p>首先，熟悉一下TO-92的引脚分布图，下图是扁平的那一面。</p><p><img src="https://i.loli.net/2020/02/23/VOgl4SpUI6MJsBX.jpg" alt="TO-92"></p><p>然后，熟悉一下树莓派的GPIO引脚分布图</p><p><img src="https://shumeipai.nxez.com/wp-content/uploads/2015/03/rpi-pins-40-0.png" alt="GPIO，图源见水印"></p><p>首先，用杜邦线把树莓派的5V和风扇的红线接到一起，电就走到风扇正极了，但此时电路还没接地，没有电流通过。</p><p>再拿一个杜邦线，把风扇的黑线和三极管的发射级（Emitter）接到一起，这样电就从风扇走到了三极管了。</p><p>再拿一根杜邦线，把三极管的集电级（Collector）和树莓派的GND地线（BOARD编码为6、9、14、20、25、30、34、39，随便选一个）接在一起，这样电就流经三极管到达地面了，电通路就完整了。</p><p>但是此时风扇不会转，因为PNP三极管默认是断开状态，除非给向它的基极（BASE）输出低电平。</p><h3 id="选择一（有钱人OR懒人）"><a href="#选择一（有钱人OR懒人）" class="headerlink" title="选择一（有钱人OR懒人）"></a>选择一（有钱人OR懒人）</h3><p>直接把三极管基极连到任意一个GPIO针脚上，完成。</p><ul><li>优势：省了一小步</li><li>劣势：三极管寿命会很短</li></ul><h3 id="选择二"><a href="#选择二" class="headerlink" title="选择二"></a>选择二</h3><p>拿出一根杜邦线，再拿1个1kΩ的电阻，把三极管基极和电阻接起来。</p><p>再拿出一根杜邦线，把电阻另一头和某个GPIO针脚连起来，我用的是18号（BCM编号）的GPIO针脚。</p><p>恭喜，硬件安装完成。</p><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><h3 id="安装python以及pip"><a href="#安装python以及pip" class="headerlink" title="安装python以及pip"></a>安装python以及pip</h3><p>在Terminal中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python</span><br><span class="line">sudo apt install python-pip</span><br></pre></td></tr></table></figure><h3 id="RPi-GPIO库"><a href="#RPi-GPIO库" class="headerlink" title="RPi.GPIO库"></a>RPi.GPIO库</h3><p>在Terminal中输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install RPi.GPIO</span><br></pre></td></tr></table></figure><p>创建一个Python文件：cool.py，记住文件的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> RPi <span class="keyword">import</span> GPIO</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 超过40度启动</span></span><br><span class="line">upper_temp = <span class="number">40</span></span><br><span class="line"><span class="comment"># 低于35度关闭</span></span><br><span class="line">lower_temp = <span class="number">35</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 采用BCM引脚编号</span></span><br><span class="line">GPIO.setmode(GPIO.BCM)</span><br><span class="line"><span class="comment"># 关闭警告</span></span><br><span class="line">GPIO.setwarnings(<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 控制三级管的GPIO编号</span></span><br><span class="line">channel = <span class="number">18</span></span><br><span class="line"><span class="comment"># 初始GPIO输出高电平, 风扇不转</span></span><br><span class="line">GPIO.setup(channel, GPIO.OUT, initial = GPIO.HIGH)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取树莓派温度的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_temp</span>():</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/sys/class/thermal/thermal_zone0/temp&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(fp.read()) / <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入检测</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 获取当前温度</span></span><br><span class="line">        temp = get_temp()</span><br><span class="line">        <span class="built_in">print</span> temp</span><br><span class="line">        <span class="comment"># 如果大于上限, 则给低电平, 闭合三极管</span></span><br><span class="line">        <span class="keyword">if</span> temp &gt;= upper_temp:</span><br><span class="line">            GPIO.output(channel, GPIO.LOW)</span><br><span class="line">        <span class="keyword">elif</span> temp &lt; lower_temp: <span class="comment"># 低于下限, 则给高电平, 断开三极管</span></span><br><span class="line">            GPIO.output(channel, GPIO.HIGH)</span><br><span class="line">        <span class="comment"># 每隔10秒检测1次</span></span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">except</span> Exception, e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置GPIO状态</span></span><br><span class="line">GPIO.cleanup()</span><br></pre></td></tr></table></figure><p>接下来，在root账户下测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">python3 cool.py</span><br></pre></td></tr></table></figure><p>出现如下图所示即为成功。</p><p><img src="https://i.loli.net/2020/02/25/3plbNGr4WMgsXjK.png" alt="test"></p><h2 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h2><p>进入Terminal，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务描述</span></span><br><span class="line">Description=smart fan</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">简单服务</span></span><br><span class="line">Type=simple</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行用户与用户组</span></span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进程退出立即重启</span></span><br><span class="line">Restart=always</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行命令，后面目录自行更改</span></span><br><span class="line">ExecStart=/usr/bin/python /root/cool.py</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在系统启动后加载UNIT</span></span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable pi-temp.service</span><br><span class="line">sudo systemctl start pi-temp.service</span><br></pre></td></tr></table></figure><p>恭喜，完成配置！</p><h2 id="最后-点赞，收藏，评论！！"><a href="#最后-点赞，收藏，评论！！" class="headerlink" title="最后:点赞，收藏，评论！！"></a>最后:点赞，收藏，评论！！</h2>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/">树莓派</category>
      
      
      <comments>https://yuzh.tech/posts/raspi_smart_fan/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>如何为你心爱的树莓派4B装上Ubuntu Server 18.04 LTS (armhf)</title>
      <link>https://yuzh.tech/posts/raspi_ubuntu_deploy/</link>
      <guid>https://yuzh.tech/posts/raspi_ubuntu_deploy/</guid>
      <pubDate>Sat, 22 Feb 2020 13:00:00 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;前言：虽然Canonical已经发布了Ubuntu Server 18.04，但是驱动好像并不完善，而Arm64的软件源远不及Armhf，于是便有了这篇自己折腾出来的安装教程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;所需装备：一台树莓派4B，一张大于等于8G的SD卡，一根网线&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>前言：虽然Canonical已经发布了Ubuntu Server 18.04，但是驱动好像并不完善，而Arm64的软件源远不及Armhf，于是便有了这篇自己折腾出来的安装教程。</p></blockquote><blockquote><p>所需装备：一台树莓派4B，一张大于等于8G的SD卡，一根网线</p></blockquote><span id="more"></span><h2 id="下载Ubuntu并完成烧录"><a href="#下载Ubuntu并完成烧录" class="headerlink" title="下载Ubuntu并完成烧录"></a>下载Ubuntu并完成烧录</h2><h3 id="下载Ubuntu"><a href="#下载Ubuntu" class="headerlink" title="下载Ubuntu"></a>下载Ubuntu</h3><p>前往<a href="https://wiki.ubuntu.com/ARM/RaspberryPi">Ubuntu Wiki</a>，下载ubuntu-18.04.3-preinstalled-server-armhf+raspi3.img.xz</p><p><img src="https://i.loli.net/2020/02/22/U2osiMEFJ7DTeOv.png" alt=" ubuntu-18.04.3-preinstalled-server-armhf+raspi3.img.xz "></p><h3 id="烧录Ubuntu"><a href="#烧录Ubuntu" class="headerlink" title="烧录Ubuntu"></a>烧录Ubuntu</h3><h4 id="下载balelnaEtcher"><a href="#下载balelnaEtcher" class="headerlink" title="下载balelnaEtcher"></a>下载balelnaEtcher</h4><p>前往<a href="https://www.balena.io/etcher/">balenaEtcher官网</a>下载，版本自选。</p><p><img src="https://i.loli.net/2020/02/22/pQs5agCUucVvljM.png" alt="balelnaEtcher"></p><h4 id="烧录镜像文件"><a href="#烧录镜像文件" class="headerlink" title="烧录镜像文件"></a>烧录镜像文件</h4><p>注意备份！！烧录会格式化你的存储设备！！</p><ol><li>选择你下载的镜像文件</li><li>选择你的SD卡</li><li>Flash！</li></ol><p><img src="https://i.loli.net/2020/02/22/EhB5u32tDrdbcSF.png" alt="flash"></p><h2 id="覆盖原有驱动"><a href="#覆盖原有驱动" class="headerlink" title="覆盖原有驱动"></a>覆盖原有驱动</h2><ol><li>将原有boot分区文件删除</li><li>下载<a href="https://www.lanzous.com/i9kw4oj">boot驱动包</a></li><li>解压后把所有文件粘贴至boot分区</li></ol><p>完成！</p><h2 id="开机并远程ssh"><a href="#开机并远程ssh" class="headerlink" title="开机并远程ssh"></a>开机并远程ssh</h2><p>把SD卡插入树莓派，插电，插网线，启动。</p><p>等待约1分钟时间，进入路由器管理界面，有一台名为ubuntu的设备。记录下IP地址。</p><p><img src="https://i.loli.net/2020/02/22/C82FMv9WzxUodye.png" alt="Ubuntu IP"></p><p>打开Powershell，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh ubuntu@你记录到的IP</span><br></pre></td></tr></table></figure><p>初始密码为ubuntu，接下来按照提示操作。先输入一遍ubuntu，然后设置自己想要的密码。</p><h2 id="更换更新源"><a href="#更换更新源" class="headerlink" title="更换更新源"></a>更换更新源</h2><p>编辑文件&#x2F;etc&#x2F;apt&#x2F;sources.list</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>输入内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiverse</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-backports main restricted universe multiverse</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-security main restricted universe multiverse</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-security main restricted universe multiverse</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">预发布软件源，不建议启用</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure><p>Ctrl+O保存，然后Ctrl+X退出。</p><p>更新软件及系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><p>恭喜，成功在树莓派4B上安装Ubuntu Server 18.04！</p><h2 id="点赞，收藏，评论！！"><a href="#点赞，收藏，评论！！" class="headerlink" title="点赞，收藏，评论！！"></a>点赞，收藏，评论！！</h2>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/">树莓派</category>
      
      
      <comments>https://yuzh.tech/posts/raspi_ubuntu_deploy/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>如何利用本地服务器，解锁网易云音乐客户端变灰歌曲</title>
      <link>https://yuzh.tech/posts/net_ease_unlock/</link>
      <guid>https://yuzh.tech/posts/net_ease_unlock/</guid>
      <pubDate>Fri, 21 Feb 2020 13:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;侵权删！侵权删！侵权删！&quot;&gt;&lt;a href=&quot;#侵权删！侵权删！侵权删！&quot; class=&quot;headerlink&quot; title=&quot;侵权删！侵权删！侵权删！&quot;&gt;&lt;/a&gt;侵权删！侵权删！侵权删！&lt;/h1&gt;&lt;h1 id=&quot;侵权请告示-x32-50-51-x35-57-x3</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="侵权删！侵权删！侵权删！"><a href="#侵权删！侵权删！侵权删！" class="headerlink" title="侵权删！侵权删！侵权删！"></a>侵权删！侵权删！侵权删！</h1><h1 id="侵权请告示-x32-50-51-x35-57-x34-51-x38-48-x39-64-x71-x71-x2e-x63-x6f-x6d-，会立刻删除！"><a href="#侵权请告示-x32-50-51-x35-57-x34-51-x38-48-x39-64-x71-x71-x2e-x63-x6f-x6d-，会立刻删除！" class="headerlink" title="侵权请告示&#x32;&#50;&#51;&#x35;&#57;&#x34;&#51;&#x38;&#48;&#x39;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#x6d;，会立刻删除！"></a>侵权请告示<a href="mailto:&#x32;&#50;&#51;&#x35;&#57;&#x34;&#51;&#x38;&#48;&#x39;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#x6d;">&#x32;&#50;&#51;&#x35;&#57;&#x34;&#51;&#x38;&#48;&#x39;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#x6d;</a>，会立刻删除！</h1><h1 id="如何利用本地服务器，解锁网易云音乐客户端变灰歌曲"><a href="#如何利用本地服务器，解锁网易云音乐客户端变灰歌曲" class="headerlink" title="如何利用本地服务器，解锁网易云音乐客户端变灰歌曲"></a>如何利用本地服务器，解锁网易云音乐客户端变灰歌曲</h1><h2 id="安装nodejs及git"><a href="#安装nodejs及git" class="headerlink" title="安装nodejs及git"></a>安装nodejs及git</h2><p>前文已有提到，此处不再赘述。</p><p><a href="/2020/02/19/hexo-first-deploy/#%E5%AE%89%E8%A3%85nodejs-1">如何安装nodejs及git</a></p><h2 id="安装UnblockNeteaseMusic"><a href="#安装UnblockNeteaseMusic" class="headerlink" title="安装UnblockNeteaseMusic"></a>安装UnblockNeteaseMusic</h2><h3 id="Git-Clone-目标仓库"><a href="#Git-Clone-目标仓库" class="headerlink" title="Git Clone 目标仓库"></a>Git Clone 目标仓库</h3><p>进入Terminal或Powershell，输入如下命令Clone仓库内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/nondanee/UnblockNeteaseMusic.git</span><br><span class="line">cd UnblockNeteaseMusic</span><br></pre></td></tr></table></figure><p>获取网易云服务器地址，并复制下来，如下图所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping music.163.com</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/02/21/j1I4TDflkzX8n9L.png" alt="ping"></p><p>使用node开启服务，-p后面的是端口号，自行设置，-f后面的是你获取到的ip地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js -p 8000 -f 59.111.181.38</span><br></pre></td></tr></table></figure><p>等待数秒，你会看到下图的东西</p><p><img src="https://i.loli.net/2020/02/21/72OdpsMIHNh4e5o.png" alt="server running"></p><p>恭喜，成功90%</p><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><h3 id="Windows配置"><a href="#Windows配置" class="headerlink" title="Windows配置"></a>Windows配置</h3><h4 id="UWP网易云音乐"><a href="#UWP网易云音乐" class="headerlink" title="UWP网易云音乐"></a>UWP网易云音乐</h4><p>打开Powershell（以管理员身份运行）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checknetisolation loopbackexempt -a -n=&quot;1F8B0F94.122165AE053F_j2p0p5q0044a6&quot;</span><br></pre></td></tr></table></figure><p>成功后会显示OK</p><p><img src="https://i.loli.net/2020/02/21/2yGfdhKgq1NMX8a.png" alt="OK"></p><p>进入设置—网络与Internet—代理</p><ol><li><p>打开自动检测设置</p></li><li><p>输入你所用的代理服务器的IPv4地址与代理的端口号</p></li></ol><p><img src="https://i.loli.net/2020/02/21/XBT45AVpIky62cJ.png" alt="Proxy"></p><p>保存设置，重启网易云音乐即可</p><h4 id="Windows客户端"><a href="#Windows客户端" class="headerlink" title="Windows客户端"></a>Windows客户端</h4><p>进入网易云音乐—左下角设置—工具—自定义代理</p><p>服务器填代理服务器的IPv4地址，端口填代理服务器所用的端口即可</p><h3 id="Android配置"><a href="#Android配置" class="headerlink" title="Android配置"></a>Android配置</h3><p>我这里用的是荣耀畅玩6A，EMUI5.1，向上兼容。</p><ol><li><p>进入WLAN设置</p></li><li><p>长按服务器所在的Wifi，修改网络</p></li></ol><p><img src="https://i.loli.net/2020/02/21/DFvs9O4YK5HC3Mr.png" alt="修改网络"></p><ol start="3"><li>显示高级选项</li></ol><p><img src="https://i.loli.net/2020/02/21/7dRVWBGxe8nQcCg.png" alt="高级选项"></p><ol start="4"><li>设置自动代理，PAC地址为 http:&#x2F;&#x2F;&lt;服务器IP地址&gt;:&lt;端口号&gt;&#x2F;proxy.pac</li></ol><p><img src="https://i.loli.net/2020/02/22/78mW5GhvK9do4IP.png" alt="PAC"></p><p>打开网易云音乐，成功！</p><h3 id="iPhone配置"><a href="#iPhone配置" class="headerlink" title="iPhone配置"></a>iPhone配置</h3><p>类似Android配置，不再赘述。</p><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>恭喜，成功解锁网易云变灰歌曲！</p><h2 id="点赞，转发，收藏！！"><a href="#点赞，转发，收藏！！" class="headerlink" title="点赞，转发，收藏！！"></a>点赞，转发，收藏！！</h2>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E5%B9%B2%E8%B4%A7/">干货</category>
      
      
      <comments>https://yuzh.tech/posts/net_ease_unlock/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>如何将Hexo博客框架上传至Github Page，搭建免费个人主页</title>
      <link>https://yuzh.tech/posts/hexo_git_deploy/</link>
      <guid>https://yuzh.tech/posts/hexo_git_deploy/</guid>
      <pubDate>Thu, 20 Feb 2020 00:00:00 GMT</pubDate>
      
      <description>将Hexo博客框架上传至Github Page，搭建免费个人主页</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="如何将Hexo博客框架上传至Github-Page，搭建免费个人主页"><a href="#如何将Hexo博客框架上传至Github-Page，搭建免费个人主页" class="headerlink" title="如何将Hexo博客框架上传至Github Page，搭建免费个人主页"></a>如何将Hexo博客框架上传至Github Page，搭建免费个人主页</h1><blockquote><p>本文是前文<a href="/2020/02/19/hexo-first-deploy/">从零开始 Hexo博客搭建</a>的后续。</p></blockquote><span id="more"></span><h2 id="注册Github账号并新建Github-Page仓库"><a href="#注册Github账号并新建Github-Page仓库" class="headerlink" title="注册Github账号并新建Github Page仓库"></a>注册Github账号并新建Github Page仓库</h2><ol><li>进入<a href="https://github.com/">Github.com</a>注册，网站会给邮箱发一封邮件</li></ol><p><img src="https://i.loli.net/2020/02/20/GQX7YlVtx8d9ZO3.png" alt="Github 注册"></p><ol start="2"><li>新建Github仓库，注意：仓库名必须为你的用户名！！</li></ol><p><img src="https://i.loli.net/2020/02/20/OADauy4iWV3bXd6.png" alt="新建Github 仓库"></p><h2 id="配置SSH，提高安全性"><a href="#配置SSH，提高安全性" class="headerlink" title="配置SSH，提高安全性"></a>配置SSH，提高安全性</h2><p>进入Terminal或Powershell，设置SSH</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面自行设置用于注册Github的邮箱，然后敲3下回车</span></span><br><span class="line">ssh-keygen -t rsa -C &quot;mail@mail.com&quot;</span><br></pre></td></tr></table></figure><p>你会得到如下图所示的密钥，不用管，说明成功了</p><p><img src="https://i.loli.net/2020/02/20/YGuUvAl4LEzHNIr.png" alt="SHA 256"></p><p>接下来进入用户目录&#x2F;.ssh&#x2F;id_rsa.pub（根据自己的电脑，Windows与Linux均适用），复制文档内容</p><p><img src="https://i.loli.net/2020/02/20/2kU3MXxmhsoaOZw.png" alt="id_rsa.pub"></p><p>接下来右上角进入Settings，左边栏SSH &amp; GPG Keys，New SSH Key，将之前复制的东西粘贴下来</p><p><img src="https://i.loli.net/2020/02/20/lnT2cGBXUhIeOQs.png" alt="SSH Key"></p><p>进入Terminal或Powershell，输入下面的命令测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会出现Are you sure you want to <span class="built_in">continue</span> connecting (<span class="built_in">yes</span>/no)?的提示，输入<span class="built_in">yes</span></span></span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>然后如果出现下图所示的提示，代表成功了！</p><p><img src="https://i.loli.net/2020/02/20/6OhiGfC8gNeWv1M.png" alt="successful authenticated"></p><p>接下来还差最后一步，配置账户名和邮箱</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yuzh0816&quot;</span><br><span class="line">git config --global user.email  &quot;2235943809@qq.com&quot;</span><br></pre></td></tr></table></figure><p>大功告成，我们已经拥有了完整的博客仓库配置！！</p><h2 id="修改博客配置，以成功上传至Github-Pages"><a href="#修改博客配置，以成功上传至Github-Pages" class="headerlink" title="修改博客配置，以成功上传至Github Pages"></a>修改博客配置，以成功上传至Github Pages</h2><h3 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改_config.yml"></a>修改_config.yml</h3><p>进入博客根目录，编辑_config.yml，翻到最下面</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="comment"># repo 根据自己的账户来填写</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:yuzh0816/yuzh0816.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>如下图所示</p><p><img src="https://i.loli.net/2020/02/20/xtZsLaVupibFglR.png" alt="deploy"></p><h3 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g # 也可以hexo g -d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hexo d : hexo deploy，部署Hexo</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hexo g : hexo generate，生成博客</span></span><br></pre></td></tr></table></figure><h2 id="如何访问Github-Pages"><a href="#如何访问Github-Pages" class="headerlink" title="如何访问Github Pages"></a>如何访问Github Pages</h2><p>进入_____.github.io即可</p>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E5%B9%B2%E8%B4%A7/">干货</category>
      
      
      <comments>https://yuzh.tech/posts/hexo_git_deploy/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>从零开始 Hexo博客搭建</title>
      <link>https://yuzh.tech/posts/hexo-first-deploy/</link>
      <guid>https://yuzh.tech/posts/hexo-first-deploy/</guid>
      <pubDate>Wed, 19 Feb 2020 13:00:00 GMT</pubDate>
      
      <description>简易搭建Hexo静态博客</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="从零开始-Hexo博客搭建"><a href="#从零开始-Hexo博客搭建" class="headerlink" title="从零开始 Hexo博客搭建"></a>从零开始 Hexo博客搭建</h1><blockquote><p>Hexo是一款快速、简洁且高效的博客框架</p></blockquote><span id="more"></span><hr><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="Windows-篇"><a href="#Windows-篇" class="headerlink" title="Windows 篇"></a>Windows 篇</h3><h4 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h4><p>进入nodejs中文网下载<a href="http://nodejs.cn/download/">nodejs</a>，32位64位安装包自选</p><p><img src="https://i.loli.net/2020/03/04/fv8qg1F5XlE3RSY.png" alt="nodejs download"></p><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p>进入git官网下载<a href="https://git-scm.com/download/">git</a>，直接下载Windows包</p><p><img src="https://i.loli.net/2020/02/19/PIHqCmcSkxOs4vL.png" alt="git download"></p><h3 id="Debian-Linux篇"><a href="#Debian-Linux篇" class="headerlink" title="Debian Linux篇"></a>Debian Linux篇</h3><h4 id="安装nodejs-1"><a href="#安装nodejs-1" class="headerlink" title="安装nodejs"></a>安装nodejs</h4><p>同理，进入nodejs中文网下载<a href="http://nodejs.cn/download/">nodejs</a>,根据环境选择安装源码</p><p><img src="https://i.loli.net/2020/02/19/8Qhwg5DTOEGtjSN.png" alt="nodejs download"></p><p>我这里是树莓派4B，选择ARM v7，复制下载链接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载</span></span><br><span class="line">wget https://npm.taobao.org/mirrors/node/v12.16.0/node-v12.16.0-linux-armv7l.tar.xz</span><br></pre></td></tr></table></figure><p>然后解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压并移动位置</span></span><br><span class="line">tar -xvf node-v12.16.0-linux-armv7l.tar.xz -C /usr/local/</span><br></pre></td></tr></table></figure><p>进入目录并改名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">mv node-v5.10.1-linux-x64/ nodejs</span><br></pre></td></tr></table></figure><p>创建硬链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/nodejs/bin/node /usr/local/bin</span><br><span class="line">ln -s /usr/local/nodejs/bin/npm /usr/local/bin</span><br></pre></td></tr></table></figure><p>测试是否已安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>进入Terminal或者Powershell,使用npm下载Hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><blockquote><p>如果是Linux系统，请执行 ln -s &#x2F;usr&#x2F;local&#x2F;nodejs&#x2F;bin&#x2F;npm &#x2F;usr&#x2F;local&#x2F;bin 创建硬链接</p></blockquote><p>接下来，执行下列命令，创建Hexo源码包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下列&lt;folder&gt;请自行改名</span></span><br><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="Hexo基本操作"><a href="#Hexo基本操作" class="headerlink" title="Hexo基本操作"></a>Hexo基本操作</h2><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><ul><li><p>运行Hexo(默认4000端口)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></li><li><p>新建文章(存放在source&#x2F;_posts中，以Markdown作为写作语言)</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下列&lt;title&gt;请自行改名</span></span><br><span class="line">hexo new &lt;title&gt;</span><br></pre></td></tr></table></figure><ul><li>新建页码(存放在source中)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下列&lt;title&gt;请自行改名</span></span><br><span class="line">hexo new page &lt;title&gt;</span><br></pre></td></tr></table></figure><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><blockquote><p>Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例</span></span><br><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2020/1/1 00:00:00</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>下图展示了如何设置Front-matter</p><p><img src="https://i.loli.net/2020/02/19/iBEcsNvbnxTd5P4.png" alt="how to set front-matter"></p><p>这就是Hexo的博客的入门搭建啦！恭喜成功搭建的小伙伴们！</p><h2 id="最后-点赞，收藏！！"><a href="#最后-点赞，收藏！！" class="headerlink" title="最后:点赞，收藏！！"></a>最后:点赞，收藏！！</h2>]]></content:encoded>
      
      
      
      
      <comments>https://yuzh.tech/posts/hexo-first-deploy/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>P1044</title>
      <link>https://yuzh.tech/posts/P1044/</link>
      <guid>https://yuzh.tech/posts/P1044/</guid>
      <pubDate>Thu, 02 Jan 2020 13:21:14 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;卡特兰数经典例题&quot;&gt;&lt;a href=&quot;#卡特兰数经典例题&quot; class=&quot;headerlink&quot; title=&quot;卡特兰数经典例题&quot;&gt;&lt;/a&gt;卡特兰数经典例题&lt;/h1&gt;&lt;h3 id=&quot;原题链接：栈&quot;&gt;&lt;a href=&quot;#原题链接：栈&quot; class=&quot;headerlink&quot; title=&quot;原题链接：栈&quot;&gt;&lt;/a&gt;原题链接：&lt;a href=&quot;https://www.luogu.org/problem/P1044&quot;&gt;栈&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;解决方法：-Catalan-Number&quot;&gt;&lt;a href=&quot;#解决方法：-Catalan-Number&quot; class=&quot;headerlink&quot; title=&quot;解决方法： Catalan Number&quot;&gt;&lt;/a&gt;解决方法： &lt;em&gt;&lt;strong&gt;Catalan Number&lt;/strong&gt;&lt;/em&gt;&lt;/h3&gt;&lt;p&gt;为何是卡特兰数？解释原理：&lt;/p&gt;
&lt;p&gt;x为最后一个出栈的，可以将原来的栈分为两部分&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="卡特兰数经典例题"><a href="#卡特兰数经典例题" class="headerlink" title="卡特兰数经典例题"></a>卡特兰数经典例题</h1><h3 id="原题链接：栈"><a href="#原题链接：栈" class="headerlink" title="原题链接：栈"></a>原题链接：<a href="https://www.luogu.org/problem/P1044">栈</a></h3><h3 id="解决方法：-Catalan-Number"><a href="#解决方法：-Catalan-Number" class="headerlink" title="解决方法： Catalan Number"></a>解决方法： <em><strong>Catalan Number</strong></em></h3><p>为何是卡特兰数？解释原理：</p><p>x为最后一个出栈的，可以将原来的栈分为两部分</p><span id="more"></span><ul><li><p>小于x(x-1个)</p></li><li><p>大于x(n-x个)</p></li></ul><p>排列后可得x的取值为catalan[x]&#x3D;catalan[x-1]*catalan[n-x]</p><p>直接动归 可得 ans&#x3D;catalan[0]*catalan[n-1]+catalan[1]catalan[n-2]+…+catalan[n-1]*catalan[0]</p><p>上述语句即为卡特兰数的公式</p><p>参见<a href="https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/6125746?fr=aladdin">百度百科</a><br><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=1cfe77909d0a304e462fa8a8b0a1cce3/4d086e061d950a7be3e94d5000d162d9f3d3c942.jpg" alt="卡特兰数_百度百科"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P1044     Stack</span></span><br><span class="line"><span class="comment">//SOLUTION: Catalan Number</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> catalan[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">catalan[<span class="number">0</span>]=<span class="number">1</span>;catalan[<span class="number">1</span>]=<span class="number">1</span>;catalan[<span class="number">2</span>]=<span class="number">2</span>;<span class="comment">//定义卡特兰数前几个数的值</span></span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n<span class="number">-1</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line">catalan[i]+=catalan[j]*catalan[i-j<span class="number">-1</span>];<span class="comment">//计算需要的卡特兰数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;catalan[n];<span class="comment">//输出答案</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本片题解基于 @inexistent改编</p>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E9%A2%98%E8%A7%A3/">题解</category>
      
      
      <comments>https://yuzh.tech/posts/P1044/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>快速幂</title>
      <link>https://yuzh.tech/posts/Fast_Exponentiation/</link>
      <guid>https://yuzh.tech/posts/Fast_Exponentiation/</guid>
      <pubDate>Thu, 02 Jan 2020 13:20:39 GMT</pubDate>
      
      <description>&lt;p&gt;简单记录快速幂原理&lt;/p&gt;
&lt;p&gt;以a^11为例：&lt;/p&gt;
&lt;p&gt;11的二进制数为1011，二进制从右向左算，但乘出来的顺序是 a^(2^0)*a^(2^1)*a^(2^3)，是从左向右的。我们不断的让base *&amp;#x3D; base目的是累乘，以便随时对ans做出贡献。&lt;/p&gt;
&lt;p&gt;要理解base *&amp;#x3D; base这一步：因为base * base &amp;#x3D;&amp;#x3D; base ^ 2，下一步再乘，就是(base ^ 2) * (base ^ 2) &amp;#x3D;&amp;#x3D; base ^ 4，然后同理(base ^ 4) * (base ^ 4) &amp;#x3D;&amp;#x3D; base ^ 8，由此可以做到base  base ^ 2  base ^ 4  base ^ 8  base ^ 16  base ^ 32…….指数正好是 2 ^ i 。再看上面的例子，a&amp;#x3D; (a ^ 1) * (a ^ 2) * (a ^ 8)，这三项就可以完美解决了，快速幂就是这样。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>简单记录快速幂原理</p><p>以a^11为例：</p><p>11的二进制数为1011，二进制从右向左算，但乘出来的顺序是 a^(2^0)*a^(2^1)*a^(2^3)，是从左向右的。我们不断的让base *&#x3D; base目的是累乘，以便随时对ans做出贡献。</p><p>要理解base *&#x3D; base这一步：因为base * base &#x3D;&#x3D; base ^ 2，下一步再乘，就是(base ^ 2) * (base ^ 2) &#x3D;&#x3D; base ^ 4，然后同理(base ^ 4) * (base ^ 4) &#x3D;&#x3D; base ^ 8，由此可以做到base  base ^ 2  base ^ 4  base ^ 8  base ^ 16  base ^ 32…….指数正好是 2 ^ i 。再看上面的例子，a&#x3D; (a ^ 1) * (a ^ 2) * (a ^ 8)，这三项就可以完美解决了，快速幂就是这样。</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x,y,ans;<span class="comment">//Bottom_Number,Time,Answer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qp</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b)</span><span class="comment">//Quick Power</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1</span>,cnt=a;</span><br><span class="line">    <span class="keyword">while</span>(b)<span class="comment">//Cacluate Answer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)<span class="comment">//b is an odd number</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans*=cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt*=cnt;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;<span class="comment">//AS b=b/2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qp2</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> r=<span class="number">1</span>,base=a;</span><br><span class="line">    <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b%<span class="number">2</span>) r*=base;</span><br><span class="line">    base*=base;</span><br><span class="line">    b/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    ans=<span class="built_in">qp</span>(x,y);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文参考<a href="https://blog.csdn.net/liangllhahaha/article/details/82119378">@LL_Leung</a></p>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E7%A7%91%E6%99%AE/">科普</category>
      
      
      <comments>https://yuzh.tech/posts/Fast_Exponentiation/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>辗转相除法</title>
      <link>https://yuzh.tech/posts/Euclidean_Algorithm/</link>
      <guid>https://yuzh.tech/posts/Euclidean_Algorithm/</guid>
      <pubDate>Thu, 02 Jan 2020 13:19:56 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;什么是辗转相除法&quot;&gt;&lt;a href=&quot;#什么是辗转相除法&quot; class=&quot;headerlink&quot; title=&quot;什么是辗转相除法&quot;&gt;&lt;/a&gt;什么是辗转相除法&lt;/h2&gt;&lt;p&gt;欧几里德算法又称辗转相除法，是指用于计算两个正整数a，b的最大公约数。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fromtitle=%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95&amp;fromid=4625352&quot;&gt;From Baidu&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;辗转相除法递归式&quot;&gt;&lt;a href=&quot;#辗转相除法递归式&quot; class=&quot;headerlink&quot; title=&quot;辗转相除法递归式&quot;&gt;&lt;/a&gt;辗转相除法递归式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;gcd(a,b) &amp;#x3D; gcd(b,a mod b)&lt;/strong&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="什么是辗转相除法"><a href="#什么是辗转相除法" class="headerlink" title="什么是辗转相除法"></a>什么是辗转相除法</h2><p>欧几里德算法又称辗转相除法，是指用于计算两个正整数a，b的最大公约数。</p><p><a href="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fromtitle=%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95&fromid=4625352">From Baidu</a></p><h2 id="辗转相除法递归式"><a href="#辗转相除法递归式" class="headerlink" title="辗转相除法递归式"></a>辗转相除法递归式</h2><p><strong>gcd(a,b) &#x3D; gcd(b,a mod b)</strong></p><span id="more"></span><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>a可以表示成a &#x3D; kb + r（a，b，k，r皆为正整数，且r&lt;b），则r &#x3D; a mod b</p><p>假设d是a,b的一个公约数，记作d|a,d|b，即a和b都可以被d整除。</p><p>而r &#x3D; a - kb，两边同时除以d，r&#x2F;d&#x3D;a&#x2F;d-kb&#x2F;d&#x3D;m，由等式右边可知m为整数，因此d|r</p><p>因此d也是b,a mod b的公约数</p><p>假设d是b,a mod b的公约数, 则d|b,d|(a-k*b),k是一个整数。</p><p>进而d|a.因此d也是a,b的公约数</p><p>因此(a,b)和(b,a mod b)的公约数是一样的，其最大公约数也必然相等，得证。</p><h2 id><a href="#" class="headerlink" title></a></h2><p>上代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = m % n;</span><br><span class="line">        m = n;</span><br><span class="line">        n = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">gcd</span>(a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E7%A7%91%E6%99%AE/">科普</category>
      
      
      <comments>https://yuzh.tech/posts/Euclidean_Algorithm/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>P1009 阶乘之和</title>
      <link>https://yuzh.tech/posts/P1009/</link>
      <guid>https://yuzh.tech/posts/P1009/</guid>
      <pubDate>Thu, 02 Jan 2020 13:18:05 GMT</pubDate>
      
      <description>&lt;p&gt;此题&lt;strong&gt;最简单&lt;/strong&gt;的方法，其实前面已经有大佬&lt;a href=&quot;https://www.luogu.org/user/69196&quot;&gt;@SocietyNiu&lt;/a&gt;讲过了，就是用&lt;strong&gt;Python&lt;/strong&gt;做一个简单的打表&lt;/p&gt;
&lt;p&gt;步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先输入打表后的数据&lt;/li&gt;
&lt;li&gt;输入数据&lt;/li&gt;
&lt;li&gt;输出表中的答案&lt;/li&gt;
&lt;/ol&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>此题<strong>最简单</strong>的方法，其实前面已经有大佬<a href="https://www.luogu.org/user/69196">@SocietyNiu</a>讲过了，就是用<strong>Python</strong>做一个简单的打表</p><p>步骤</p><ol><li>先输入打表后的数据</li><li>输入数据</li><li>输出表中的答案</li></ol><span id="more"></span><p>贴上代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string a[<span class="number">60</span>]=&#123;<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;33&quot;</span>,<span class="string">&quot;153&quot;</span>,<span class="string">&quot;873&quot;</span>,<span class="string">&quot;5913&quot;</span>,<span class="string">&quot;46233&quot;</span>,<span class="string">&quot;409113&quot;</span>,<span class="string">&quot;4037913&quot;</span>,<span class="string">&quot;43954713&quot;</span>,<span class="string">&quot;522956313&quot;</span>,<span class="string">&quot;6749977113&quot;</span>,<span class="string">&quot;93928268313&quot;</span>,<span class="string">&quot;1401602636313&quot;</span>,<span class="string">&quot;22324392524313&quot;</span>,<span class="string">&quot;378011820620313&quot;</span>,<span class="string">&quot;6780385526348313&quot;</span>,<span class="string">&quot;128425485935180313&quot;</span>,<span class="string">&quot;2561327494111820313&quot;</span>,<span class="string">&quot;53652269665821260313&quot;</span>,<span class="string">&quot;1177652997443428940313&quot;</span>,<span class="string">&quot;27029669736328405580313&quot;</span>,<span class="string">&quot;647478071469567844940313&quot;</span>,<span class="string">&quot;16158688114800553828940313&quot;</span>,<span class="string">&quot;419450149241406189412940313&quot;</span>,<span class="string">&quot;11308319599659758350180940313&quot;</span>,<span class="string">&quot;316196664211373618851684940313&quot;</span>,<span class="string">&quot;9157958657951075573395300940313&quot;</span>,<span class="string">&quot;274410818470142134209703780940313&quot;</span>,<span class="string">&quot;8497249472648064951935266660940313&quot;</span>,<span class="string">&quot;271628086406341595119153278820940313&quot;</span>,<span class="string">&quot;8954945705218228090637347680100940313&quot;</span>,<span class="string">&quot;304187744744822368938255957323620940313&quot;</span>,<span class="string">&quot;10637335711130967298604907294846820940313&quot;</span>,<span class="string">&quot;382630662501032184766604355445682020940313&quot;</span>,<span class="string">&quot;14146383753727377231082583937026584420940313&quot;</span>,<span class="string">&quot;537169001220328488991089808037100875620940313&quot;</span>,<span class="string">&quot;20935051082417771847631371547939998232420940313&quot;</span>,<span class="string">&quot;836850334330315506193242641144055892504420940313&quot;</span>,<span class="string">&quot;34289376947494122614363304694584807557656420940313&quot;</span>,<span class="string">&quot;1439295494700374021157505910939096377494040420940313&quot;</span>,<span class="string">&quot;61854558558074209658512637979453093884758552420940313&quot;</span>,<span class="string">&quot;2720126133346522977702138448994068984204397080420940313&quot;</span>,<span class="string">&quot;122342346998826717539665299944651784048588130840420940313&quot;</span>,<span class="string">&quot;5624964506810915667389970728744906677010239883800420940313&quot;</span>,<span class="string">&quot;264248206017979096310354325882356886646207872272920420940313&quot;</span>,<span class="string">&quot;12678163798554051767172643373255731925167694226950680420940313&quot;</span>,<span class="string">&quot;620960027832821612639424806694551108812720525606160920420940313&quot;</span>,<span class="string">&quot;31035053229546199656252032972759319953190362094566672920420940313&quot;</span>&#125;;<span class="comment">//此处为超水打表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="type">int</span> n;</span><br><span class="line">      cin&gt;&gt;n;<span class="comment">//读入他想让你计算的和</span></span><br><span class="line">      cout&lt;&lt;a[n];<span class="comment">//输出答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面附上<strong>Python</strong>打表源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ans=<span class="number">1</span></span><br><span class="line">k=<span class="number">2</span></span><br><span class="line">last=<span class="number">1</span></span><br><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">while</span> k&lt;=n:</span><br><span class="line">    last*=i</span><br><span class="line">    <span class="built_in">sum</span>+=last</span><br><span class="line">    k+=<span class="number">1</span></span><br><span class="line">    f.write(<span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">    f.write(<span class="built_in">str</span>(ans))</span><br><span class="line">    f.write(<span class="string">&#x27;&quot;,&#x27;</span>)</span><br></pre></td></tr></table></figure><p>配上AC链接<a href="https://www.luogu.org/record/24483665">yuzh0816 的 AC记录</a></p>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E9%A2%98%E8%A7%A3/">题解</category>
      
      
      <comments>https://yuzh.tech/posts/P1009/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>平分子集</title>
      <link>https://yuzh.tech/posts/Bisection_Subset/</link>
      <guid>https://yuzh.tech/posts/Bisection_Subset/</guid>
      <pubDate>Thu, 02 Jan 2020 13:12:52 GMT</pubDate>
      
      <description>&lt;h5 id=&quot;参考博客&quot;&gt;&lt;a href=&quot;#参考博客&quot; class=&quot;headerlink&quot; title=&quot;参考博客&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn.net/zhangfei2018/article/details/8107514&quot;&gt;参考博客&lt;/a&gt;&lt;/h5&gt;&lt;h4 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;img src=&quot;http://5.135.58.179:7009/pictures/pro_pics/p40/1.PNG&quot; alt=&quot;题目描述&quot;&gt;&lt;/h4&gt;&lt;p&gt;&lt;em&gt;&lt;em&gt;对于从1到N的连续整集合，划分为两个子集合，且保证每个集合的数字和是相等的。因而，划分之后每个子集全的数字应该为n&lt;/em&gt;(n+1)&amp;#x2F;2的一半，即n&lt;/em&gt;(n+1)&amp;#x2F;4由于两个子集中都是整数，所以n*(n+1)必为偶数，则可以设s&amp;#x3D;n*(n+1),并判断s%4 .则，s&amp;#x2F;&amp;#x3D;4是划分之后子集合的数字和；dyn[i]数组表示任意个数加起来等于i的组数。**&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h5 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a><a href="https://blog.csdn.net/zhangfei2018/article/details/8107514">参考博客</a></h5><h4 id><a href="#" class="headerlink" title></a><img src="http://5.135.58.179:7009/pictures/pro_pics/p40/1.PNG" alt="题目描述"></h4><p><em><em>对于从1到N的连续整集合，划分为两个子集合，且保证每个集合的数字和是相等的。因而，划分之后每个子集全的数字应该为n</em>(n+1)&#x2F;2的一半，即n</em>(n+1)&#x2F;4由于两个子集中都是整数，所以n*(n+1)必为偶数，则可以设s&#x3D;n*(n+1),并判断s%4 .则，s&#x2F;&#x3D;4是划分之后子集合的数字和；dyn[i]数组表示任意个数加起来等于i的组数。**</p><span id="more"></span><p>题解如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line"><span class="type">int</span> n,s;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">s=n*(n<span class="number">+1</span>);</span><br><span class="line"><span class="keyword">if</span>(s%<span class="number">4</span>!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">s/=<span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line">ans[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(j=s;j&gt;=i;j--)</span><br><span class="line">ans[j]+=ans[j-i];</span><br><span class="line">cout&lt;&lt;ans[s]/<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E9%A2%98%E8%A7%A3/">题解</category>
      
      
      <comments>https://yuzh.tech/posts/Bisection_Subset/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hanoi</title>
      <link>https://yuzh.tech/posts/Hanoi/</link>
      <guid>https://yuzh.tech/posts/Hanoi/</guid>
      <pubDate>Thu, 02 Jan 2020 13:11:41 GMT</pubDate>
      
      <description>&lt;p&gt;河内塔(Towers of Hanoi)是法国人M.Claus(Lucas)于1883年从泰国带至法国的，河内之塔为越战时北越的首都&lt;br&gt;，即现在的胡志明市；1883年法国数学家Edouar Lucas曾提及这个故事，据说创世纪时Benares有一座波罗教塔，&lt;br&gt;是由三支钻石棒所支撑，开始时神在第一根棒上放置64个由上至下依由小到大排列的金盘(Disc)，并命令僧侣将&lt;br&gt;所有的金盘从第一根石棒移至第三根石棒，且搬运过程中遵守大盘子在小盘子之下的原则，若每日仅搬一个盘子，&lt;br&gt;则当盘子全数搬运完毕之时，此塔将毁损，而也就是世界末日的来临之时。&lt;/p&gt;
&lt;p&gt;解法：&lt;br&gt;如果柱子标为ABC，要由A搬至C，在只有一个盘子时，就将它直接搬至C，当有两个盘子，就将B当作辅助柱。如果&lt;br&gt;盘数超过两个，将第三个以下的盘子遮起来，就很简单了，每次处理两个盘子，也就是：A-&amp;gt;B，A-&amp;gt;C，B-&amp;gt;C这三个&lt;br&gt;步骤，而被遮住的部分，其实就是进入程式的递回处理。事实上，若有n个盘子，则先移动完毕所需次数为(2^n)-1，&lt;br&gt;所以当盘数为64时，则所需次数为(2^64)-1 &amp;#x3D; 18446744073709551615为5.05390248594782e+16年，也就是约5000&lt;br&gt;世纪，如果对这数字没什么概念，就假设每秒钟搬一个盘子好了，也要5850亿年左右。 &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>河内塔(Towers of Hanoi)是法国人M.Claus(Lucas)于1883年从泰国带至法国的，河内之塔为越战时北越的首都<br>，即现在的胡志明市；1883年法国数学家Edouar Lucas曾提及这个故事，据说创世纪时Benares有一座波罗教塔，<br>是由三支钻石棒所支撑，开始时神在第一根棒上放置64个由上至下依由小到大排列的金盘(Disc)，并命令僧侣将<br>所有的金盘从第一根石棒移至第三根石棒，且搬运过程中遵守大盘子在小盘子之下的原则，若每日仅搬一个盘子，<br>则当盘子全数搬运完毕之时，此塔将毁损，而也就是世界末日的来临之时。</p><p>解法：<br>如果柱子标为ABC，要由A搬至C，在只有一个盘子时，就将它直接搬至C，当有两个盘子，就将B当作辅助柱。如果<br>盘数超过两个，将第三个以下的盘子遮起来，就很简单了，每次处理两个盘子，也就是：A-&gt;B，A-&gt;C，B-&gt;C这三个<br>步骤，而被遮住的部分，其实就是进入程式的递回处理。事实上，若有n个盘子，则先移动完毕所需次数为(2^n)-1，<br>所以当盘数为64时，则所需次数为(2^64)-1 &#x3D; 18446744073709551615为5.05390248594782e+16年，也就是约5000<br>世纪，如果对这数字没什么概念，就假设每秒钟搬一个盘子好了，也要5850亿年左右。 </p><span id="more"></span><p>C++解法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> A, <span class="type">int</span> B, <span class="type">int</span> C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Move sheet %d from %c to %c\n&quot;</span>, n, A, C);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">hanoi</span>(n<span class="number">-1</span>, A, C, B);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Move sheet %d from %c to %c\n&quot;</span>, n, A, C);</span><br><span class="line">        <span class="built_in">hanoi</span>(n<span class="number">-1</span>, B, A, C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入盘数: \n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">hanoi</span>(n, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="https://yuzh.tech/tags/%E7%A7%91%E6%99%AE/">科普</category>
      
      
      <comments>https://yuzh.tech/posts/Hanoi/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
